<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>The CCNx URI Scheme</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language"/>
<link href="#rfc.section.2" rel="Chapter" title="2 URI path segment grammar for label=value pairs"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Labeled Segments"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 URI comparison"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Application to CCNx Names"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 The ccnx Scheme"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 URI Representation"/>
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Examples"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 ccnx: URI comparison"/>
<link href="#rfc.section.4" rel="Chapter" title="4 IRI Considerations"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Acknowledgements"/>
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations"/>
<link href="#rfc.references" rel="Chapter" title="8 References"/>
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Mosko, M. and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-mosko-icnrg-ccnxuri-03" />
  <meta name="dct.issued" scheme="ISO8601" content="2016-2" />
  <meta name="dct.abstract" content="This document defines an RFC3986 URI compliant identifier called a Labeled Segment URI in which name segments carry a label. This allows differentiation between unrelated resources with similar identifiers. This document also specifies the CCNx URI scheme, called &quot;ccnx:,&quot; which conforms to the labeled segment encoding rules presented here. The CCNx URI scheme applies specific labels to each name segment of a URI to disambiguate between resources with similar names. This document defines a specific set of segment labels with label semantics.  " />
  <meta name="description" content="This document defines an RFC3986 URI compliant identifier called a Labeled Segment URI in which name segments carry a label. This allows differentiation between unrelated resources with similar identifiers. This document also specifies the CCNx URI scheme, called &quot;ccnx:,&quot; which conforms to the labeled segment encoding rules presented here. The CCNx URI scheme applies specific labels to each name segment of a URI to disambiguate between resources with similar names. This document defines a specific set of segment labels with label semantics.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">ICNRG</td>
  <td class="right">M. Mosko</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">PARC, Inc.</td>
</tr>
<tr>
  <td class="left">Intended status: Experimental</td>
  <td class="right">C. Wood</td>
</tr>
<tr>
  <td class="left">Expires: August 4, 2016</td>
  <td class="right">University of California Irvine</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">February 2016</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">The CCNx URI Scheme<br />
  <span class="filename">draft-mosko-icnrg-ccnxuri-03</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document defines an RFC3986 URI compliant identifier called a Labeled Segment URI in which name segments carry a label. This allows differentiation between unrelated resources with similar identifiers. This document also specifies the CCNx URI scheme, called "ccnx:," which conforms to the labeled segment encoding rules presented here. The CCNx URI scheme applies specific labels to each name segment of a URI to disambiguate between resources with similar names. This document defines a specific set of segment labels with label semantics.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on August 4, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2016 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a></li>
</ul><li>2.   <a href="#rfc.section.2">URI path segment grammar for label=value pairs</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Labeled Segments</a></li>
<li>2.2.   <a href="#rfc.section.2.2">URI comparison</a></li>
</ul><li>3.   <a href="#rfc.section.3">Application to CCNx Names</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">The ccnx Scheme</a></li>
<li>3.2.   <a href="#rfc.section.3.2">URI Representation</a></li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Examples</a></li>
</ul><li>3.3.   <a href="#rfc.section.3.3">ccnx: URI comparison</a></li>
</ul><li>4.   <a href="#rfc.section.4">IRI Considerations</a></li>
<li>5.   <a href="#rfc.section.5">Acknowledgements</a></li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a></li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a></li>
<li>8.   <a href="#rfc.references">References</a></li>
<ul><li>8.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">A Labeled Segment is an <a href="#RFC3986">URI</a> <cite title="NONE">[RFC3986]</cite> compliant convention that allows an application or protocol to embed labels in name segments, thus disambiguating the resource identified by the path.  Labeled Segment URIs also allow for query and fragment components to follow the Labeled Segment form.  </p>
<p id="rfc.section.1.p.2">Some protocols may wish to disambiguate name segments between different identifier spaces, such as "version" and "page".  Other protocols may wish to use a type system such as "/str=parc/int=7" and "/str=parc/str=7".  Labeled Segment URIs provide an unambiguous and flexible representation in systems that allow resources with otherwise similar names.</p>
<p id="rfc.section.1.p.3">It is not sufficient to leave the determination of type to application-specific conventions.  In a networked system with multiple applications accessing resources generated by other applications, there needs to be a set of common conventions.  For example, if one application uses a base 64 encoding of a frame number, e.g. base64(0xbdea), and another uses "ver=" to represent a document version, there is an ambiguity because base64(0xbdea) is the string "ver=".</p>
<p id="rfc.section.1.p.4">Labeled Segments defines "ls-segment" as "label[:param]=value", where the value only contains unreserved, percent-encoded, or certain sub-delim characters.  In the previous example, one application would say "/frame=%BD%EA" and the other would say "/ver=".</p>
<p id="rfc.section.1.p.5">In this document, we use <a href="#RFC3986">URI</a> <cite title="NONE">[RFC3986]</cite> terminology, therefore a URI and CCNx Name are both composed of a URI path, which is a collection  of name segments.  We do not use the term "name component" as was common in old CCNx. In this document, the word "segment" alone means "name segment."</p>
<p id="rfc.section.1.p.6">URIs conforming to the CCNx URI scheme carry a label for each name segment.  The contents of each name segment must conform to the label semantics.  Example segment types are "Binary Segment", "Name", and "KeyId".</p>
<p id="rfc.section.1.p.7">We use Labeled Segment URIs as the canonical, human-readable representation.  There is an unambiguous, one-to-one correspondence between an absolute LS-URI path and a Labeled Name.  Relative URI representations are removed during encoding, so no relative name ends up in wire format.  Some labels are URIs that are <a href="#RFC3987">IRI</a> <cite title="NONE">[RFC3987]</cite> compatible.</p>
<p id="rfc.section.1.p.8">Labeled Names shall be used everywhere a Name is used in CCNx, such as in the Name of an Interest or Content Object.  They are also used in Links, KeyLocators, or any other place requiring a name.  When encoded for the wire, a binary representation is used, depending on the specific wire format codec, which is outside the scope of this document.  </p>
<p id="rfc.section.1.p.9">This document specifies: </p>

<ul>
  <li>the ccnx scheme.</li>
  <li>a canonical URI representation.</li>
</ul>

<p> </p>
<p id="rfc.section.1.p.10">Formal grammars use the <a href="#RFC5234">ABNF</a> <cite title="NONE">[RFC5234]</cite> notation.</p>
<p id="rfc.section.1.p.11">TODO: We have not adopted Requirements Language yet.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#LSU" id="LSU">URI path segment grammar for label=value pairs</a></h1>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#segments" id="segments">Labeled Segments</a></h1>
<p id="rfc.section.2.1.p.1">This section describes the formal grammar for Labeled Segments using <a href="#RFC5234">ABNF</a> <cite title="NONE">[RFC5234]</cite> notation.  We do not impose restrictions on the length of labels or values.  The semantics of values are URI scheme specific, here we only describe the meta-structure of Labeled Segments.  We begin by reviewing some definitions from <a href="#RFC3986">[RFC3986]</a> that define an absolute path URI.</p>
<pre>
URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
hier-part     = "//" authority path-abempty
                / path-absolute
                / &lt;other path types&gt;
path-absolute = "/" [ segment-nz *( "/" segment ) ]
segment       = *pchar
segment-nz    = 1*pchar
pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
query         = *( pchar / "/" / "?" )
fragment      = *( pchar / "/" / "?" )
pct-encoded   = "%" HEXDIG HEXDIG
unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
reserved      = gen-delims / sub-delims
gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims    = "!" / "$" / "&amp;" / "'" / "(" / ")"
                    / "*" / "+" / "," / ";" / "="
</pre>
<p id="rfc.section.2.1.p.2">Labeled Segments defines a new segment type that provides unambiguous representation of a segment's label and its value.  We define the top-level LS-URI as the same form as a URI, wherein each part conforms to the Label Segment grammar, which is a subset of the URI grammar.</p>
<pre>
LS-URI           = scheme ":" ls-hier-part ["?" ls-query]
                   ["#" fragment]
ls-hier-part     = ["//" authority] ls-path-absolute
ls-path-absolute = "/" [ first-segment *( "/" ls-segment ) ]
first-segment    = *lpv-segment-nz
ls-segment       = lpv-segment / v-segment
lpv-segment      = label [":" param] "=" *s-value-nz
v-segment        = *s-value-nz
ls-segment-nz    = lpv-segment-nz / v-segment-nz
lpv-segment-nz   = label [":" param] "=" s-value-nz
v-segment-nz     = s-value-nz
label            = alpha-t / num-t
param            = alpha-t / num-t
s-value-nz       = 1*(s-pchar)

ls-query         = *1 ( lpv-component / v-component
                        *( "&amp;" (lpv-component / v-component) ) )
lpv-component    = label [":" param] "=" q-value
v-component      = q-value
q-value          = *(q-pchar)

alpha-t          = ALPHA *(ALPHA / DIGIT)
num-t            = dec-t / hex-t
dec-t            = 1*(DIGIT)
hex-t            = "0x" 1*(HEXDIG)
ls-pchar         =  unreserved / pct-encoded / ls-sub-delims
s-pchar          = ls-pchar / ":" / "@" / "&amp;"
q-pchar          = ls-pchar / ":" / "@" / "/"
ls-sub-delims    = "!" / "$" / "'" / "(" / ")"
                       / "*" / "+" / "," / ";"
</pre>
<p id="rfc.section.2.1.p.3">A Labeled Segment URI (LS-URI) contains a scheme that uses Labeled Segments, an optional authority, a labeled segment absolute path (ls-path-aboslute), an optional labeled segment query (ls-query), and a fragment.  The authority is URI scheme specific and the fragment is independent of the URI scheme.</p>
<p id="rfc.section.2.1.p.4">the ls-path-aboslute is a first-segment followed by zero or more "/" ls-segment.  The first-segment may be empty or a non-zero lpv-segment (lpv-segment-nz).  If it is empty, it corresponds to a 0-lenght name which typically is a default route.  It is distinct from a 1-segment name with no value.  The first-segment MUST either be empty (the 0-lenght name) or MUST have a value.  If the first-segment is an lpv-segment-nz, then it will have a value.</p>
<p id="rfc.section.2.1.p.5">An ls-segment may (lpv-segment) or may not (v-segment) have a label.  A particular LS-URI scheme MUST define how unlabeled segments are processed, and MAY disallow them.  A v-segment is an implied type.  Once the implied type is resolved, it functions like an lpv-segment.</p>
<p id="rfc.section.2.1.p.6">An lpv-segment has a label, optional parameter, and optional value (s-value-nz).  An empty value is a 0-length name segment with a defined type.  This is distinct from a 0-length first-segment, which has neither type nor value.</p>
<p id="rfc.section.2.1.p.7">lpv-segment values come from the s-pchar set, which excludes the "=" equal sign.  This means that the only equal sign in a name segment must be the delimiter between the label:param and the value.  Within the value, an equal sign must be percent encoded.</p>
<p id="rfc.section.2.1.p.8">lpv-segment labels and values may be alpha-numeric identifiers or numbers (decimal or hexadecimal).  For example, one scheme may define the labels "name", "version", and "frame".  A version may be of types "date" or "serial", meaning that the version is either a date or a monotonic serial number.  Some examples of resulting LS-URIs are: "/name=parc/name=csl/version:date=20130930" or "/name=alice_smith/version:serial=299".  The parameters may also indicate an instance of a label, such as "/name=books/year:1=1920/year:3=1940", where there are scheme or application semantics associated with "year:1" and "year:3".</p>
<p id="rfc.section.2.1.p.9">lpv-segment labels and parameters may also be numbers.  For example, a protocol with a binary and URI representation may not have pre-defined all possible labels. In such cases, it could render unknown labels as their binary value, such as "/name=marc/x2003=green".</p>
<p id="rfc.section.2.1.p.10">The ls-query component is a non-hierarchical set of components separated by "&amp;".  Each ls-query component is either a lpv-component or a v-component, similar to segments.  They are based on q-value, which uses q-pchar that excludes "&amp;", but includes "/".  This allows an LS-URI scheme to use type query parameters.</p>
<p id="rfc.section.2.1.p.11">Labeled Segments allow for dot-segments "." and ".." in a v-segment.  They operate as normal.  A single dot "." refers to the current hierarchy level and may be elided when the URI is resolved.  Double dot ".." segments pop off the previous non-dot segment.  An lpv-segment with a value of "." or ".." is not a dot-segment.  It means that the value of the given label is "." or "..".  For example /a=parc/b=csl/.. is equivalent to "/a=parc/b=csl", but the LS-URI "/a=parc/b=csl/c=.." does not contain a dot-segment.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#compare" id="compare">URI comparison</a></h1>
<p id="rfc.section.2.2.p.1">An LS-URI scheme MUST specify the normalization rules to be used, following the methods of <a href="#RFC3986">Section 6</a> <cite title="NONE">[RFC3986]</cite>.  At minimum, an LS-URI scheme SHOULD do the following: </p>

<ul>
  <li>Normalize unrestricted percent-encodings to the unrestricted form.</li>
  <li>Normalize num-t to either dec-t or hex-t.</li>
  <li>If the scheme allows for value-only segments or query components and interprets them as a default type, they should be normalized to having the type specified.</li>
  <li>If the scheme allows for undefined labels and represents them, for example, as num-t, then it should normalize all labels to their corresponding num-t.  If "name", for example, is known to be %x50 in a binary encoding of the URI, then all labels should be compared using their numeric value.</li>
</ul>

<p> </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#CCNx" id="CCNx">Application to CCNx Names</a></h1>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#labels" id="labels">The ccnx Scheme</a></h1>
<p id="rfc.section.3.1.p.1">This section describes the CCNx URI scheme "ccnx:" for Labeled Names.  A Labeled Name assigns a semantic type or label to each segment of the hierarchical content Name.</p>
<p id="rfc.section.3.1.p.2">Unless otherwise specified, a name segment is an arbitrary sequence of octets.</p>
<p id="rfc.section.3.1.p.3">Several name segment labels are binary unsigned integers.  These are always encoded as variable length sequences of 1 or more octets in network byte order using the shortest representation (i.e. no leading %x00).  The value of "0" is encoded as the single byte of "%x00".  A zero-length sequence must be interpreted as "not present."</p>
<p id="rfc.section.3.1.p.4">The CCNx Name segment types are: </p>

<ul>
  <li>Name Segment: A generic name segment that includes arbitrary octets.</li>
  <li>Application Type N: An application may use application-specific parameters, numbered as integers, where N is from 0 to a system-specific maximum, not less than 255.  These are represented as "App:1=value", for example.</li>
</ul>

<p> </p>
<p id="rfc.section.3.1.p.5">It is common for an information centric networking protocol, such as CCNx or NDN, to use a binary on-the-wire representation for messages.  Such protocols, if they use the ccnx: scheme, must have an appropriate codec that unambiguously represents Labeled Content Information in the chosen wire format.  Relative dot-segments should not occur in the wire format, they should be resolved before encoding.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#URI" id="URI">URI Representation</a></h1>
<p id="rfc.section.3.2.p.1">Typed Names use a standard RFC 3986 representation following the LS-URI convention.  A name segment consists of any "unreserved" characters plus percent-encoded characters.  Reserved characters must be percent encoded.</p>
<p id="rfc.section.3.2.p.2">Within an absolute path, each segment consists of an "ls-segment" (c.f. LS-URI).  A labeled segment is a type and a name component value, with a URI representation of "type=value".  The "type=" portion may be omitted if it is type Name.</p>
<p id="rfc.section.3.2.p.3">Some name types take a parameter, such as the Application types.  They are represented as "A:nnn=value", where the "nnn" is the application type number and value is the name component.</p>
<p id="rfc.section.3.2.p.4">A CCNx URI MUST NOT include an Authority, Query, or Fragment.  It is an error to include them.</p>
<p id="rfc.section.3.2.p.5">Dot-segments (relative name components) are resolved when the URI is converted to a Typed Name.  The "." dot-segment is removed.  The ".." dot-segment is removed along with the previous non-dot-segment.</p>
<div id="rfc.table.1"/>
<div id="message_type"/>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <caption>The CCNx URI Scheme Types</caption>
  <thead>
    <tr>
      <th class="center">Type</th>
      <th class="center">Display</th>
      <th class="center">Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="center">'Name'</td>
      <td class="center">Hexadecimal</td>
      <td class="center">Name Segment</td>
    </tr>
    <tr>
      <td class="center">'IPID'</td>
      <td class="center">Hexadecimal</td>
      <td class="center">Interest Payload Identifier segment</td>
    </tr>
    <tr>
      <td class="center">'App:0' - 'App:255'</td>
      <td class="center">Hexadecimal</td>
      <td class="center">Application Component</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#Examples" id="Examples">Examples</a></h1>
<pre>
A name / is
    ccnx:/ and is a 0-length name.

A name /Name= is
    ccnx:/Name= and is a 1-segment name of 0-length.

A name /foo/bar.
   ccnx:/Name=foo/Name=bar
   ccnx:/foo/Name=bar
   ccnx:/foo/bar

A name /foo/bar with key %xA0.
    ccnx:/Name=foo/Name=bar/App:1=0xA0

A name /foo/bar with version %xA0 and App:2 value 0x09.
    ccnx:/foo/bar/Version=0xA0/App:2=0x09

A name /foo/.., where the ".." is a literal name component,
not a relative dot-segment.
   ccnx:/foo/Name=..

A name /foo/bar with application type 0 "hello"
and application type 1 "world".
   ccnx:/Name=foo/Name=bar/App:0=hello/App:1=world
 </pre>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#compareb" id="compareb">ccnx: URI comparison</a></h1>
<p id="rfc.section.3.3.p.1">While most comparisons are done using a wire format representation of a ccnx: URI, some applications may compare the CCNx URI using their URI representation.  This section defines the rules for comparing ccnx: URIs using the methods of <a href="#RFC3986">Section 6</a> <cite title="NONE">[RFC3986]</cite> </p>
<p id="rfc.section.3.3.p.2">Comparing typed name URIs must be done with: </p>

<ul>
  <li>Syntax-based normalization</li>
  <li>Case normalization: normalize the representation of percent encodings.  ccnx: does not use the host portion of the URI, and should be ignored if present.</li>
  <li>Percent encoding normalization: Percent encodings of unreserved characters must be converted to the unreserved character.</li>
  <li>Path segment normalization: dot-segments must be resolved first.</li>
  <li>Scheme-based normalization: The authority should be removed and the path represented as an absolute path.</li>
  <li>Protocol-based normalization: Should not be done.  A trailing slash indicates a zero-length terminal name component and signifies a different name.</li>
  <li>typed-name-segment normalization: All segments should be presented with their type, do not elide the "N=" for Name components.</li>
  <li>Binary unsigned integer normalization: remove any leading %x00 from numbers, leaving only the terminal %x00 for "0".</li>
  <li>type parameters: they must have their percent encodings normalized.  If they are integers, such as for the 'A' type, they must not have leading zeros.</li>
</ul>

<p> </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#IRI" id="IRI">IRI Considerations</a></h1>
<p id="rfc.section.4.p.1">International Resource Identifiers extend the unreserved character set to include characters above U+07F and encode them using percent encoding.  This extension is compatible with the ccnx: schema.  It applies only to the "value" portion of an ls-segment.</p>
<p id="rfc.section.4.p.2">The canonical name is determined by the URI representation of the IRI, after applying the rules of Section 3.1 of <a href="#RFC3987">[RFC3987]</a> and resolving dot-segments.  The canonical name thus includes the URI representation of language markers, including the bidirectional components.</p>
<p id="rfc.section.4.p.3">The value of a UTF-8 Name segment should be interpreted using IRI rules, including bidirectional markers.  They may be displayed using localized formats.</p>
<p id="rfc.section.4.p.4">Binary unsigned integer types are not interpreted under IRI rules, they are specifically percent encoded numbers.  They may be displayed using a localized format.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a></h1>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#IANA" id="IANA">IANA Considerations</a></h1>
<p id="rfc.section.6.p.1">This memo includes no request to IANA.</p>
<p id="rfc.section.6.p.2">All drafts are required to have an IANA considerations section (see <a href="#RFC5226">Guidelines for Writing an IANA Considerations Section in RFCs</a> <cite title="NONE">[RFC5226]</cite> for a guide). If the draft does not require IANA to do anything, the section contains an explicit statement that this is the case (as above). If there are no requirements for IANA, the section will be removed during conversion into an RFC by the RFC Editor.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#Security" id="Security">Security Considerations</a></h1>
<p id="rfc.section.7.p.1">All drafts are required to have a security considerations section. See <a href="#RFC3552">RFC 3552</a> <cite title="NONE">[RFC3552]</cite> for a guide.</p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC3552">[RFC3552]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3986">[RFC3986]</b>
      </td>
      <td class="top"><a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3987">[RFC3987]</b>
      </td>
      <td class="top"><a>Duerst, M.</a> and <a>M. Suignard</a>, "<a href="http://tools.ietf.org/html/rfc3987">Internationalized Resource Identifiers (IRIs)</a>", RFC 3987, DOI 10.17487/RFC3987, January 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5226">[RFC5226]</b>
      </td>
      <td class="top"><a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5234">[RFC5234]</b>
      </td>
      <td class="top"><a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="http://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Marc Mosko</span> 
	  <span class="n hidden">
		<span class="family-name">Mosko</span>
	  </span>
	</span>
	<span class="org vcardline">PARC, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Palo Alto</span>,  
		<span class="region">California</span> 
		<span class="code">94304</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +01 650-812-4405</span>

<span class="vcardline">EMail: <a href="mailto:marc.mosko@parc.com">marc.mosko@parc.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">University of California Irvine</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Irvine</span>,  
		<span class="region">California</span> 
		<span class="code">92697</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +01 315-806-5939</span>

<span class="vcardline">EMail: <a href="mailto:woodc1@uci.edu">woodc1@uci.edu</a></span>

  </address>
</div>

</body>
</html>
