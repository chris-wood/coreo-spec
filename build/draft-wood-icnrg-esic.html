<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Encrypted Sessions In CCNx (ESIC)</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions and Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Stateless packet keys"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Inner and Outer Contexts"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Outer Context Names"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Outer Packet"/>
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Sender Outer Packet"/>
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Receiver Outer Packet"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Processing Chain"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Transport State Machine"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Control Channel"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 ESIC Control Packets"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 ESIC Control Messages"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.references" rel="Chapter" title="6 References"/>
<link href="#rfc.references.1" rel="Chapter" title="6.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="6.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Sample API"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Mosko, M. and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-wood-icnrg-esic-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-3-11" />
  <meta name="dct.abstract" content="This document describes how to transport CCNx packets inside an encrypted session between peers &#8211; a sender and receiver &#8211; that share a traffic secret, such as that which is derived from " />
  <meta name="description" content="This document describes how to transport CCNx packets inside an encrypted session between peers &#8211; a sender and receiver &#8211; that share a traffic secret, such as that which is derived from " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">ICNRG Working Group</td>
  <td class="right">M. Mosko</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">PARC, Inc.</td>
</tr>
<tr>
  <td class="left">Intended status: Experimental</td>
  <td class="right">C. Wood</td>
</tr>
<tr>
  <td class="left">Expires: September 12, 2017</td>
  <td class="right">University of California Irvine</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">March 11, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Encrypted Sessions In CCNx (ESIC)<br />
  <span class="filename">draft-wood-icnrg-esic-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes how to transport CCNx packets inside an encrypted session between peers &#8211; a sender and receiver &#8211; that share a traffic secret, such as that which is derived from <a href="#CCNxKE">[CCNxKE]</a>. The peers create an outer naming context to identify the encryption session in one direction between the sender and the receiver. The sender issues encrypted Interest messages to the receiver, who responds with encrypted Content Objects.  Inside the outer context, the sender sends Interests with different names, for which the receiver may reply to or send InterestReturns in response.  There does not need to be a naming relationship between the outer names and the inner names.  The inner content is still protected by normal CCNx authentication mechanisms and possibly encrypted under other schemes.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 12, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Conventions and Terminology</a></li>
</ul><li>2.   <a href="#rfc.section.2">Stateless packet keys</a></li>
<li>3.   <a href="#rfc.section.3">Inner and Outer Contexts</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Outer Context Names</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Outer Packet</a></li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Sender Outer Packet</a></li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Receiver Outer Packet</a></li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Processing Chain</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Transport State Machine</a></li>
</ul><li>4.   <a href="#rfc.section.4">Control Channel</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">ESIC Control Packets</a></li>
<li>4.2.   <a href="#rfc.section.4.2">ESIC Control Messages</a></li>
</ul><li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.references">References</a></li>
<ul><li>6.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>6.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Sample API</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">CCNx packets <a href="#MESSAGES">[MESSAGES]</a> contain a fixed header, optional hop-by-hop headers, a CCNx Message, and a validation section.  Encrypted Sessions in CCNx (ESIC) describes how to to transport encrypted CCNx packets inside other CCNx packets.  The outer packet (the wrapper) uses a CCNx name that identifies the encrypted session while the inner (encrypted) portion remains hidden and private to an outside observer.</p>
<p id="rfc.section.1.p.2">ESIC defines a new field Encapsulated (T_ENCAP) that may occur in both an Interest (T_INTEREST) and Content Object (T_OBJECT).  The T_ENCAP field contains the encryption of the inner CCNx packet, be it an Interest or Content Object.</p>
<p id="rfc.section.1.p.3">Because the use of an outer CCNxPacket, the total packet length of the inner CCNxPacket may need to be limited to less than the maximum of 64 KB.  ESIC allows the use of a compressor before the encryptor, so it is likely that a packet that would overflow the 64 KB limit could be compressed by enough to allow for an outer CCNxPacket.  This consideration for the PacketLength is separate from concerns about path MTU.</p>
<p id="rfc.section.1.p.4">It is a requirement of ESIC that one inner packet fit in one outer packet.  This is because ESIC does not define a method to issue extra outer interests to fetch extra outer content objects.  It relies entirely on Interests generated by the sender application.</p>
<p id="rfc.section.1.p.5">ESIC defines a control channel within the outer context by using special names with the inner packets.  These names allow signaling between the two encryption endpoints for features such as alerts and rekeying requests.</p>
<p id="rfc.section.1.p.6">ESIC defines how to use a traffic secret (TS), such as derived from CCNxKE, to encrypt multiple packets in a sender-receiver session.  Each direction will use separate derived keys.  If one wishes to have a reverse traffic flow (interests from receiver fetching content objects from the sender), then one must share a second TS and use it with the roles reversed, but otherwise it works exactly as in the first case.</p>
<p id="rfc.section.1.p.7">The mechanism by which this symmetric key is obtained is outside the scope of this document; These keys could be pre-shared or derived from an online key-exchange protocol <a href="#CCNxKE">[CCNxKE]</a>.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#conventions-and-terminology" id="conventions-and-terminology">Conventions and Terminology</a></h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.1.1.p.2">The following terms are used:</p>
<p/>

<ul>
  <li>Inner Packet: A fully-formed CCNx packet (fixed header through validation) that is carried encrypted inside a T_ENCAP TLV.</li>
  <li>Outer Packet: A fully-formed CCNx packet that carries the outer context of an encrypted session.</li>
  <li>Outer Name: The name of the outer packet.</li>
  <li>Inner Name: The name of the inner packet (not visible in transport).</li>
  <li>Control channel: the use of Inner Packets to convey control signaling between encryption endpoints using a special Inner Name.</li>
</ul>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#stateless-packet-keys" id="stateless-packet-keys">Stateless packet keys</a></h1>
<p id="rfc.section.2.p.1">ESIC assumes that the sender and receiver share a Traffic Secret (TS), usually derived as per CCNxKE.  Regardless of how the TS is derived, there are four secrets derived from it, as per <a href="#CCNxKE">[CCNxKE]</a>. This specifies how to generate the Sender Write Key, Receiver Write Key, Sender Write IV, and Receiver Write IV.</p>
<p id="rfc.section.2.p.2">The AEAD nonce (IV) is derived as specified in <a href="#TLS13">[TLS13]</a>. In particular, the length of the IV for each AEAD operation is set to max(8 bytes, N_MAX), where N_MIN must be at least 8 bytes <a href="#RFC5116">[RFC5116]</a>. With this length, the nonce is initialized by:</p>
<p/>

<ol>
  <li>Padding the 64-bit per-packet AEAD sequence number to the left with zeroes so that its length is equal to the IV length.</li>
  <li>This padded sequence number is then XORed with the sender or receiver IV, depending on the role.</li>
</ol>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#inner-and-outer-contexts" id="inner-and-outer-contexts">Inner and Outer Contexts</a></h1>
<p id="rfc.section.3.p.1">The inner context is a CCNx packet with meaning to the sender and receiver.  They may be clear text or they make use additional encryption as needed.  The sender transmits an Interest packet with an Inner Name (plus other optional fields as normal) and expects to get back a Content Object or InterestReturn packet with corresponding name and fields.</p>
<p id="rfc.section.3.p.2">The outer context names the encryption session and sequences packets.  ESIC does not expect a one-to-one correspondence of outer name and inner name.  If a sender, for example, transmits 3 interests with outer names NO1, NO2, NO3 and inner names NI1, NI2, and NI3, the receiver can return those names in any order.  It could put content objects with name NI3 in NO1, NI1 in NO2, and NI2 in NO3.  ESIC does expect normal CCNx processing rules to be followed for the inner packets, therefore we would expect at most one inner packet returned for each inner Interest.  That inner packet could be either a Content Object or Interest Return.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#outer-context-names" id="outer-context-names">Outer Context Names</a></h1>
<p id="rfc.section.3.1.p.1">The outer context name is a routable prefix PREFIX followed by a session ID (SID) followed by a ChunkNumber (Chunk).  The chunk number is a monotonically increasing number.<br/> The outer name is clear text, visible to all observers.</p>
<p id="rfc.section.3.1.p.2">The PREFIX and SID are derived outside of ESIC.  In normal use with CCNxKE, the PREFIX is that which is set after the handshake completes, be it the original producer (receiver) prefix or the MovePrefix. The SID is created by the receiver and given to the sender inside CCNxKE.</p>
<pre>
OuterName := ccnx:/PREFIX/SID=sid/CHUNK=chunk
</pre>
<p id="rfc.section.3.1.p.3">Chunk numbers are limited to 8 bytes and do not wrap around.  When the sender gets near the end of the sequence number space, it must request a re-keying via the control channel.  Because CCNx in a pull-driven model, the sender is responsible for the chunk number and thus responsible for requesting the re-keying.  The receiver may also request a re-keying for its own reasons.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#outer-packet" id="outer-packet">Outer Packet</a></h1>
<p id="rfc.section.3.2.p.1">The outer packet will have a Fixed Header, per hop headers, a CCNx Message with the Outer Name, and a Validation section (ValidationAlg and ValidationPayload).  The outer packet is visible to 3rd parties in its entirety.  Only the &#8216;value&#8217; of T_ENCAP TLV field inside the CCNx Message is encrypted.  The T_ENCAP TLV Value is the AEAD &#8216;plaintext&#8217; that will be converted to the &#8216;ciphertext&#8217;.  In the outer packet, only the CCNx Message and the ValidationAlg are covered by the authentication token</p>
<p id="rfc.section.3.2.p.2">The Outer Packet has a Validation section.  The ValidationAlg will have a 0-length ValidationType of T_SESSION, which indicates that the encryption context must be derived from the SID in the name.</p>
<p id="rfc.section.3.2.p.3">The Associated Data (in AEAD) covered by the validation output is from the beignning of the CCNx Message up to but not including the T_ENCAP Value concatenated with the ValidationAlg TLV.  That is, it skips the T_ENCAP TLV Value.</p>
<p id="rfc.section.3.2.p.4">The ValidationPayload contains the AEAD authentication token.</p>
<p id="rfc.section.3.2.p.5">If the receiver cannot satisfy an Inner Packet Interest, it will encapsulate an InterestReturn inside an OuterPacket of PacketType ContentObject.  That is, the InterestReturn is end-to-end signaling about the inner context.</p>
<p id="rfc.section.3.2.p.6">If the receiver has an error with the Outer Context, it may return an InterestReturn for the outer context as normal for Interest processing.</p>
<h1 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#sender-outer-packet" id="sender-outer-packet">Sender Outer Packet</a></h1>
<p id="rfc.section.3.2.1.p.1">The outer packet from the sender to the receiver will always be of PacketType Interest.  They may have any of the normal Interest per-hop headers (e.g. InterestLifetime), which will be visible to 3rd parties and not protected by the encryption or authentication.</p>
<p id="rfc.section.3.2.1.p.2">The Outer Context has a T_INTEREST message type, which contains a T_NAME of the Outer Name.  It may have other additional metadata in clear text.  The T_INTEREST container is protected by the encryption authenticator.  Finally, the T_INTEREST has a T_ENCAP field that contains the encryption of the Inner Packet.  The encryption will use the algorithm negotiated as part of the SID (i.e. AES-GCM).</p>
<h1 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#receiver-outer-packet" id="receiver-outer-packet">Receiver Outer Packet</a></h1>
<p id="rfc.section.3.2.2.p.1">The receiver will only send PacketType ContentObject back to the sender.  The Inner packet may be either an InterestReturn or a ContentObject corresponding to the Inner Packet interest.</p>
<p id="rfc.section.3.2.2.p.2">The outer packet may have per-hop headers (e.g. RecommendedCacheTime) that affect the encrypted packet.  These are independent from the inner Per Hop headers.  The outer MessageType is always T_OBJECT.  It may have normal metadata for a content object, such as ExpiryTime, which affect only the outer packet.  Finally, it has a T_ENCAP that contains the wrapped inner Packet.</p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#processing-chain" id="processing-chain">Processing Chain</a></h1>
<p id="rfc.section.3.3.p.1">The processing chain from the Source to the Sink is shown below.  The compression/decompression stages are optional and are not strongly tied to the encrypted session.  If used, we assume the compression protocol is session specific to avoid state snooping (e.g. such as in CRIME attack).</p>
<pre>
() indicates output of stage
+------------+   +-------------+   +-----------------+   +---------+
| Source     | - | Compresser  | - | Encypter/Framer | - | Channel |
|(CCNxPacket)|   |(CCNxzPacket)|   | (CCNxPacket)    |   |         |
+------------+   +-------------+   +-----------------+   +---------+

+------------+   +--------------------+   +-------------+   +------+
| Channel    | - | Deframer/Decrypter | - | Decompressor| - | Sink |
|(CCNxPacket)|   | (CCNxzPacket)      |   | (CCNxPacket)|   |      |
+------------+   +--------------------+   +-------------+   +------+
</pre>
<p/>

<ul>
  <li>Source: The source of an Inner Packet.</li>
  <li>Compressor: Optional component to reduce the size before encryption.</li>
  <li>Encrypter/Framer: Creates the ciphertext of the CCNx(z)packet to produce the T_ENCAP, constructs the outer packet, computes the authentication token and generates the ValidationPayload.</li>
  <li>Channel: Carries the wire format outer packet</li>
  <li>Deframer/Decrypter: Verifies the authenticator, decrypts the T_ENCAP, and passes the Inner Packet to the Decompressor.</li>
  <li>Decompressor: Optional component to expand the inner packet</li>
  <li>Sink: The sink of an Inner Packet.</li>
</ul>
<p id="rfc.section.3.3.p.3">The Encrypter/Framer will generate outer names with sequential outer name chunk numbers.</p>
<p id="rfc.section.3.3.p.4">The Deframer/Decryptor will extract the SID and chunk number from the outer name and use those to create the packet key (see below).  Using the packet key, it will verify the authentication token and if successful decrypt the T_ENCAP.  The output of the T_ENCAP will then be passed to the Sink.</p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#transport-state-machine" id="transport-state-machine">Transport State Machine</a></h1>
<p id="rfc.section.3.4.p.1">ESIC uses a state machine to manage the ephemeral session such that the receiver knows when the sender is finished with the SID.  It also will try to re-request packets that fail authentication before sending its own InterestReturn up the Sink.</p>
<p id="rfc.section.3.4.p.2">The protocol begins with each side knowing the four keys (see Stateless Packet Keys below), the Session ID (SID), and the routable prefix PREFIX.</p>
<p id="rfc.section.3.4.p.3">The receiving process uses a replay buffer to prevent replay attacks.  The buffer tracks the last N out-of-order verified chunks plus the cumulative verified chunk number.</p>
<p id="rfc.section.3.4.p.4">((TODO: Sort this out how to avoid replay attacks without requiring reliable in-order delivery.))</p>
<p id="rfc.section.3.4.p.5">Protocol of Encrypter/Framer:</p>
<p/>

<ul>
  <li>Initialize: set NextChunkNumber = 0, State = Waiting</li>
  <li>Waiting: Wait for packet from Source (or compressor).  On packet receive, State = Send</li>
  <li>Send: <ul><li>Generate packet key for NextChunkNumber</li><li>Create outer packet with name /PREFIX/SID=sid/CHUNK=NextChunkNumber and the input packet as cleartext in the T_ENCAP.</li><li>Run the AEAD scheme authenticating and encrypting.  Note the prior description of the split Associated Data before and after the plaintext.</li><li>Increment NextChunkNumber</li><li>Send the packet</li><li>State = Waiting</li></ul></li>
</ul>
<p id="rfc.section.3.4.p.7">Protocol of the Deframer/Decrypter:</p>
<p/>

<ul>
  <li>Initialize the replay buffer to empty, State = Waiting.</li>
  <li>Waiting: wait for packet, on input from channel State = Receive</li>
  <li>Receive: <ul><li>Extract the SID and ChunkNumber from name</li><li>If replay, drop</li><li>Authenticate the packet <ul><li>If failed on sender, send InterestReturn to Source with &#8220;X Error&#8221; (TBD)</li><li>If failed on receiver, send failure message to Sink so it can send end-to-end InterestReturn back over channel (if desired) with &#8220;Y Error&#8221; (TBD)</li></ul></li><li>Add packet to replay buffer</li><li>Decrypt packet</li><li>Pass decrypted packet to Sink/Source (or decompressor)</li></ul></li>
</ul>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#control-channel" id="control-channel">Control Channel</a></h1>
<p id="rfc.section.4.p.1">The sender and receiver will need to exchange signaling about the encryption context.  Control and data traffic should be indistinguishable to an external observer.  Therefore, all control signaling is done within the same outer names as data traffic.</p>
<p id="rfc.section.4.p.2">Control signaling is done with a normal Inner Packet that pushes data to the other side.  We use an Interest with an Inner Name of the form shown below, where &#8216;<em>direction</em>&#8217; is &#8216;up&#8217; from the sender to receiver or &#8216;down&#8217; for the receiver to sender.  This allows each side to maintain its own sequence number space in the &#8216;seqnum&#8217;.  This is similar to the use of the sequence number in the DTLS record layer.</p>
<p id="rfc.section.4.p.3">Like DTLS, ESIC control messages are unreliable, though they are uniquely named.</p>
<p id="rfc.section.4.p.4">The payload of the control Interest uses a TLV equivalent of the TLS record format for handshake and alert messages.  Application data is never communicated in these records, as they use an Inner Packet with a different Inner Name.  Inside the payload, a TLV type of Alert (21) or Handshake (22) indicates the purpose of the TLV value.  One may concatenate multiple records into one payload.</p>
<pre>
ControlName := ccnx:/localhost/esic/_direction_/SID=sid/SEQNUM=seqnum
</pre>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#esic-control-packets" id="esic-control-packets">ESIC Control Packets</a></h1>
<p id="rfc.section.4.1.p.1">A control packet is a CCNx Interest Inner Packet.  The name of the control packet is as above in the /localhost/esic namesapce.  The Payload of the Interest is the actual data.</p>
<p id="rfc.section.4.1.p.2">The ESIC control packet SHOULD be padded out to a length that is indistinguishable from other traffic in the given <em>direction</em>.</p>
<p id="rfc.section.4.1.p.3">The Payload of the Interest contains a set of TLV records using the normal CCNx TLV encoding.  The TLV types and values are defined in the next section.</p>
<p id="rfc.section.4.1.p.4">In the &#8216;up&#8217; direction from the sender to the receiver, a control packet can be inserted into the Interest stream as normal.  The receiver may use this extra outer name to return its own control message or send a &#8220;no-op&#8221; back to consume the extra name.</p>
<p id="rfc.section.4.1.p.5">In the &#8216;down&#8217; direction from the receiver to the sender, there is no pre-allocated outer name available.  The receiver can only send the sender a control message if the sender has outstanding Interests up to the receiver.  If there is one or more outstanding interests in the outer name space, the receiver normally would send a Content Object or Interest Return corresponding to some inner name.  In this case, the receiver would instead inject a control packet Interest in the downstream.  This means the receiver is now short one outer Interest in the upstream direction.  Therefore, whenever the Deframer/Decrypter sees a control message in the downstream direction, it MUST insert an upstream &#8220;no-op&#8221; packet, padded out to statistically undetectable length, to give the receiver back a missing name slot.</p>
<p id="rfc.section.4.1.p.6">We allow one ESIC control packet in one outer packet.  However, we allow multiple Alert messages to be encoded in the payload, so long as it remains indistinguishable from other packets in the given <em>direction</em>.</p>
<p id="rfc.section.4.1.p.7">Example from a sender to a receiver, where &#8220;NO&#8221; means &#8220;name outer&#8221; and &#8220;NI&#8221; means &#8220;name inner&#8221;.</p>
<pre>
Sender                                     Receiver
   | &gt;------- NO1 : NI1 (Interest) --------&gt;   |
   | &gt;------- NO2 : NI2 (Interest) --------&gt;   |
   | &lt;------- NO1 : NI1 (ContentObject) ---&lt;   |
   | &gt;------- NO3 : NI /local/esic/up/2/1 -&gt;   |
   | &lt;------- NO3 : no-op -----------------&lt;   | (no-op)
   | &lt;------- NO2 : NI2 (ContentObject) ---&lt;   |
</pre>
<p id="rfc.section.4.1.p.8">Here is an example from a receiver to a sender.  The receiver uses the second available name NO2 to send a control message to the sender.  The sender must then send a no-op packet back up to the receiver so it can return the final data packet NI2 inside NO3.</p>
<pre>
Sender                                   Receiver
| &gt;------- NO1 : NI1 (Interest) --------&gt;   |
| &gt;------- NO2 : NI2 (Interest) --------&gt;   |
| &lt;------- NO1 : NI1 (ContentObject) ---&lt;   |
| &lt;------- NO2 : NI /local/esic/dn/2/1 -&lt;   |
| &gt;------- NO3 : -----------------------&gt;   | (no-op)
| &lt;------- NO3 : NI2 (ContentObject) ---&lt;   |
</pre>
<p id="rfc.section.4.1.p.9">((TODO: Add examples with loss))</p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#esic-control-messages" id="esic-control-messages">ESIC Control Messages</a></h1>
<p id="rfc.section.4.2.p.1">ESIC adopts the TLS 1.3 Alert Protocol for its control messages.  The TLV type of the message inside the control packet payload is taken from the enum AlertDescription.  As per TLS 1.3, fatal Alert messages are an immediate close of the ESIC session.</p>
<p id="rfc.section.4.2.p.2">As per TLS 1.3, each party MUST send a close_notify message closing the write side of the connection.  In ESIC, this means that when a sender is done requesting data, it should send a final close_notify.  The receiver should then use this outer name to send back its own close_notify.  If for some reason the receiver must close before the sender, it should inject its own close_notify discarding all remaining data and the receiver should send back upstream a close_notify.</p>
<p id="rfc.section.4.2.p.3">The KeyUpdate messages function as per TLS 1.3 Sec 6.3.5.3.  Either side may generate a KeyUpdate message and begin transmitting with the new key.  The other side must update their own key and issue its own KeyUpdate message.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">It may be possible for an observer to identify which outer packets contain a control (alert) message if the ACK response time shows significant statistical timing different from the normal flow of messages.</p>
<h1 id="rfc.references"><a href="#rfc.references">6.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">6.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr><td class="reference"><b id="CCNxKE">[CCNxKE]</b></td><td class="top"><a href="https://github.com/parc/ccnx-keyexchange-rfc">CCNx Key Exchange Protocol Version 1.0</a>", n.d..</td>, "</tr>
    <tr><td class="reference"><b id="MESSAGES">[MESSAGES]</b></td><td class="top"><a href="https://tools.ietf.org/html/draft-irtf-icnrg-ccnxmessages-04">CCNx Messages in TLV Format</a>", n.d..</td>, "</tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5116">[RFC5116]</b>
      </td>
      <td class="top"><a>McGrew, D.</a>, "<a href="http://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="TLS13">[TLS13]</b>
      </td>
      <td class="top"><a>RTFM, Inc, .</a>, <a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-19">The Transport Layer Security (TLS) Protocol Version 1.3</a>", n.d..</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">6.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC5288">[RFC5288]</b>
      </td>
      <td class="top"><a>Salowey, J.</a>, <a>Choudhury, A.</a> and <a>D. McGrew</a>, "<a href="http://tools.ietf.org/html/rfc5288">AES Galois Counter Mode (GCM) Cipher Suites for TLS</a>", RFC 5288, DOI 10.17487/RFC5288, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5389">[RFC5389]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc5389">Session Traversal Utilities for NAT (STUN)</a>", RFC 5389, DOI 10.17487/RFC5389, October 2008.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#sample-api" id="sample-api">Sample API</a></h1>
<p id="rfc.section.A.p.1">In this section we describe the ESIC API. Before doing so, we highlight some details that molded the API for both senders and receivers.</p>
<p/>

<ul>
  <li>Encrypted sessions are bound to names instead of addresses. Consequently, in addition to a set of trusted keys, sessions between a sender and receiver require only a name to be created.</li>
  <li>Sessions are created by an active sender with a passive peer (receiver). Thus, the API must reflect these roles.</li>
  <li>Senders transmit and receive whole CCNx messages over a session. Thus, simple read and write functions must be exposed via the API.</li>
  <li>Sessions are not full duplex by default. A receiver must specify in its ServerConfiguration construct that it wishes to send interests to the sender. To maintain transparency, the modality of the resulting session is not reflected in the API.</li>
</ul>
<p id="rfc.section.A.p.3">These observations are distilled in the following ESIC API.</p>
<pre>
# @Sender: create a secure session with a receiver
CCNxSecureSession *ccnxSecureSession_Connect(CCNxPortal *portal,
    PARCIdentity *identity, CCNxName *servicePrefix);

# @Receiver: create a passive listener
CCNxSecureSession *ccnxSecureSession_CreateServer(CCNxPortal *portal,
    CCNxKeyExchangeConfig *config, CCNxName *servicePrefix);

# @Receiver: accept uni- and bi-directional sessions
CCNxSecureSession *ccnxSecureSession_AcceptConnection(CCNxSecureSession *session);
CCNxSecureSession *ccnxSecureSession_AcceptBidirectionalConnection(CCNxSecureSession *session);

# Send a CCNx message
# Override the outer name with the `response` parameter if needed
void ccnxSecureSession_SendMessage(CCNxSecureSession *session,
    CCNxTlvDictionary *message, const CCNxStackTimeout *timeout, CCNxName *response);

# Receive and decapsulate a CCNx message
# Store the outer name in the `response` parameter.
CCNxMetaMessage *ccnxSecureSession_ReceiveMessage(CCNxSecureSession *session,
    const CCNxStackTimeout *timeout, CCNxName **response);
</pre>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Marc Mosko</span> 
	  <span class="n hidden">
		<span class="family-name">Mosko</span>
	  </span>
	</span>
	<span class="org vcardline">PARC, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:marc.mosko@parc.com">marc.mosko@parc.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">University of California Irvine</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:woodc1@uci.edu">woodc1@uci.edu</a></span>

  </address>
</div>

</body>
</html>
