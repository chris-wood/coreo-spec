<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>ICN "Begin-End" Hop by Hop Fragmentation</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Abstract Description of the Begin-End-Fragment Protocol"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Initialization"/>
<link href="#rfc.section.2.1.1" rel="Chapter" title="2.1.1 Examples"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Sender Protocol"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Receiver Protocol"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Ethernet as a common use case"/>
<link href="#rfc.section.4" rel="Chapter" title="4 CCNx 1.0 Fragment Protocol Description"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Initialization examples"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Example"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 CCNx 1.0 Frame Packing"/>
<link href="#rfc.section.5" rel="Chapter" title="5 NDN Fragment Protocol Description"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Example"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 NDN Frame Packing"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Assigned Numbers for NDN Begin-End fragmentation"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Acknowledgements"/>
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 CCNx Packet Type Registry"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 CCNx Message Registry"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Security Considerations"/>
<link href="#rfc.references" rel="Chapter" title="9 References"/>
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Mosko, M. and C. Tschudin" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-mosko-icnrg-beginendfragment-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-3-13" />
  <meta name="dct.abstract" content="This document describes a simple hop-by-hop fragmentation scheme for ICN and mappings to the CCNx 1.0 and NDN packet formats, called &quot;begin-end fragmentation&quot;. This scheme may be used at Layer 3 when ICN packets are used natively over a Layer 2 media which does not reorder packets." />
  <meta name="description" content="This document describes a simple hop-by-hop fragmentation scheme for ICN and mappings to the CCNx 1.0 and NDN packet formats, called &quot;begin-end fragmentation&quot;. This scheme may be used at Layer 3 when ICN packets are used natively over a Layer 2 media which does not reorder packets." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">ICNRG</td>
  <td class="right">M. Mosko</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">PARC</td>
</tr>
<tr>
  <td class="left">Intended status: Experimental</td>
  <td class="right">C. Tschudin</td>
</tr>
<tr>
  <td class="left">Expires: September 14, 2017</td>
  <td class="right">University of Basel</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">March 13, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">ICN "Begin-End" Hop by Hop Fragmentation<br />
  <span class="filename">draft-mosko-icnrg-beginendfragment-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes a simple hop-by-hop fragmentation scheme for ICN and mappings to the CCNx 1.0 and NDN packet formats, called "begin-end fragmentation". This scheme may be used at Layer 3 when ICN packets are used natively over a Layer 2 media which does not reorder packets.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 14, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a></li>
</ul><li>2.   <a href="#rfc.section.2">Abstract Description of the Begin-End-Fragment Protocol</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Initialization</a></li>
<ul><li>2.1.1.   <a href="#rfc.section.2.1.1">Examples</a></li>
</ul><li>2.2.   <a href="#rfc.section.2.2">Sender Protocol</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Receiver Protocol</a></li>
</ul><li>3.   <a href="#rfc.section.3">Ethernet as a common use case</a></li>
<li>4.   <a href="#rfc.section.4">CCNx 1.0 Fragment Protocol Description</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Initialization examples</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Example</a></li>
<li>4.3.   <a href="#rfc.section.4.3">CCNx 1.0 Frame Packing</a></li>
</ul><li>5.   <a href="#rfc.section.5">NDN Fragment Protocol Description</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Example</a></li>
<li>5.2.   <a href="#rfc.section.5.2">NDN Frame Packing</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Assigned Numbers for NDN Begin-End fragmentation</a></li>
</ul><li>6.   <a href="#rfc.section.6">Acknowledgements</a></li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">CCNx Packet Type Registry</a></li>
<li>7.2.   <a href="#rfc.section.7.2">CCNx Message Registry</a></li>
</ul><li>8.   <a href="#rfc.section.8">Security Considerations</a></li>
<li>9.   <a href="#rfc.references">References</a></li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">In the past, there were two known hop-by-hop fragmentation schemes for ICN packets: The one described in <a href="#NDNLP">NDNLP</a> <cite title="NONE">[NDNLP]</cite> as "indexed fragmentation" and the one implemented in <a href="#CCNLite">CCN-lite</a> <cite title="NONE">[CCNLite]</cite>, using the old ccnb encoding. In a first part, this document describes a third,  hop-by-hop fragmentation protocol in an encoding-neutral way. In a second part, we show mappings of this "begin-end fragmentation scheme" to the <a href="#CCNMessages">CCNx Messages in TLV Format</a> <cite title="NONE">[CCNMessages]</cite> and the NDN TLV [NDN] encoding.  Thirdly, possible extensions and their encodings are discussed, for example reporting link reliability or link ARQ schemes such as windowing protocols.</p>
<p id="rfc.section.1.p.2">The proposed hop-by-hop "begin-end fragments" scheme may be used at Layer 3 when large ICN messages are to be natively sent over a Layer 2 media with a small MTU. In cases where ICN packets are carried over an existing Layer 3 protocol, such as IP, the Information Centric Network SHOULD use that protocol's native fragmentation.  </p>
<p id="rfc.section.1.p.3">This proposed fragmentation scheme is an adaptation of PPP Multilink <a href="#RFC1990">PPP Multilink</a> <cite title="NONE">[RFC1990]</cite> fragmentation between peers identified by their Layer 2 identity. It is appropriate for standard Layer 2 media that guarantee in-order packet delivery.  </p>
<p id="rfc.section.1.p.4">Definitions: </p>

<ul>
  <li>(Network Protocol) Packet: A layer 3 ICN datagram, such as a Content Object or Interest, which is too large to be transmitted over a given L2 technology.</li>
  <li>Fragment: The datagram containing all serialized data fields required by the proposed fragmentation protocol. Depending on the mapping, the fragment will contain these fragment protocol specific data but also, for example, a CCNx fixed header, optional Per-Hop-Headers and/or and validator fields like checksums or signatures.</li>
  <li>Fragment Header: The serialized CONTROL data structures of the proposed fragmentation protocol plus mapping specific bits.</li>
  <li>Fragment Data (or payload): The portion of the original Network Protocol Packet that is carried in the Fragment.</li>
  <li>Frame: A layer-2 frame in which the Fragment will be transferred.</li>
</ul>

<p> </p>
<p id="rfc.section.1.p.5">Fragments are represented as 32-bit wide words using ASCII art.  Because of the Type-Length-Value encoding used (TLV) and optional fields or sizes, there is no concise way to represent all possibilities.  We use the convention that ASCII art fields enclosed by vertical bars "|" represent exact bit widths.  Fields with a forward slash "/" are variable bit widths, which we typically pad out to word alignment for picture readability.</p>
<p id="rfc.section.1.p.6">TODO -- we have not adopted the Requirements Language yet.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">RFC 2119</a> <cite title="NONE">[RFC2119]</cite>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#protocol" id="protocol">Abstract Description of the Begin-End-Fragment Protocol</a></h1>
<pre>
Fragment       = FragProtocolID FragProtocolData
FragProtocolID = &lt;BeginEndFragmentsProtocolID&gt; | (other protocols' ids)
FragProtocolData = BeginEndFragmentsData | (other protocols' data)
BeginEndFragmentsData = Flags FragSeqNo FragLength FragData
Flags          = B / E / BE / I
B              = &lt;begin flag&gt;
E              = &lt;end flag&gt;
BE             = &lt;begin and end flag&gt;
I              = &lt;idle flag&gt;
FragSeqNo      = 1*OCTETS
FragLength     = &lt;Octets of fragment data&gt;
FragData       = &lt;Continuous octets (portion of Packet)&gt;
</pre>
<p id="rfc.section.2.p.1">A Fragment is defined as the following fields (plus any additional fields required by the wire formatting in which fragments are encoded): </p>
<p id="rfc.section.2.p.2">The fragmentation protocol is run between a sender and a "peer", which can be one or more, potentially passive, receivers.  They execute first an <a href="#init">Initialization Protocol</a> <cite title="NONE">[init]</cite>, then use a <a href="#sender">Sender Protocol</a> <cite title="NONE">[sender]</cite> and <a href="#receiver">Receiver Protocol</a> <cite title="NONE">[receiver]</cite> to exchange frames.  </p>
<p id="rfc.section.2.p.3">The initialization protocol uses a reliable messages exchange to reset the the FragSeqNo to 0 on both peers.  This ensures that when one or another peer restarts both peers will reset their state.</p>
<p id="rfc.section.2.p.4">The sender breaks a packet P (typically an Interest- or Content packet in the embedding wire encoding) into one or more fragments which are tagged with monotonically increasing sequence numbers. The B, E and BE flags are used to signal the start of a fragment series (B), its end (E), or a single fragment (BE) for the given packet P.  </p>
<p id="rfc.section.2.p.5">It is advisable that the 'B' fragment contains enough information in its Fragment Data to let the receiver know the total length of the packet to be reconstructed (and size of the reassembly buffer to be allocated) and the type of the expected packet.  </p>
<p id="rfc.section.2.p.6">The receivers listen to the fragment stream and reconstruct from a valid fragment series the original packet, and reject fragments with invalid sequence numbers, flags, or validation data.  </p>
<p id="rfc.section.2.p.7">The 'I' flag allows the sender to send idle frames that do not contain any Fragment Data, but do increment the fragment sequence number.  This is useful on lossy links to indicate that the sender is past the end of the previous packet in case the 'E' fragment was lost.  Moreover, as a possible extension of the protocol, this allows for periodic keepalives, measuring for example link quality when there is no other traffic to send.  </p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#init" id="init">Initialization</a></h1>
<p id="rfc.section.2.1.p.1">Whenever a peer begins operation, it must reliably reset the sequence number space.  If the underlying link already ensures a complete reset of both peers, that method MAY be used.  Otherwise, the method presented here SHOULD be used.</p>
<p/>

<ol>
  <li>For each peer, a node tracks its local state, S_LOCAL[peer], and its peer's state S_REMOTE[peer].  A state may be INIT or Sync or OK, though only certain combinations are possible.</li>
  <li>A node tracks its FragSeqNo as FSN_LOCAL[peer] and the next expected FragSeqno from its peer as FSN_REMOTE[peer].</li>
  <li>A node remembers two numbers N_LOCAL[peer] and N_REMOTE[peer].  N_LOCAL is the node's own sequence number and N_REMOTE is the one learned from a peer.  These two numbers identify the current reboot of a node and serve as computation identifiers.  They may be sequence numbers or random numbers or taken from some other source that is unlikely to repeat reboot to reboot.</li>
  <li>A RESET message carries a nodes N_LOCAL[peer] value and informs the peer that it should reset it's fragment sequence numbers.</li>
  <li>Upon receiving a RESET, a node will set N_REMOTE[peer] to the RESET number and will send a RESETACK message to acknowledge the RESET and to inform the peer of it's own N_LOCAL[peer] number.  Thus a RESET mesage carries one value and a RESETACK carries two values.</li>
  <li>We will drop the [peer] subscript from the state variables in the following with the understanding that this protocol executes per pair of peers.</li>
  <li>If a node is not in the OK/OK state, it MUST send only RESET or RESETACK messages.</li>
  <li>Upon sending a first RESET message, the sending node starts a retransmit timer for the peer.  It begins at RESET_TIMOUT (50 msec).</li>
  <li>At each RESET timeout, a node sets a new timeout as twice the previous timeout.  If it is less than MAX_TIMEOUT (4 seconds), it sends {RESET, N_LOCAL} again and starts a reset timer with the new timeout.</li>
  <li>Upon receiving a valid RESETACK that matches a node's N_LOCAL, the RESET timeout is set back to RESET_TIMEOUT.</li>
</ol>

<p> </p>
<p id="rfc.section.2.1.p.3">The <a href="#python-sim">ccnx-beginendfragment-sim</a> <cite title="NONE">[python-sim]</cite> software package is a Python simulator of the sequence number reset algorithm.  It uses simple discrete event simulator to validate the reset algorithm under various conditions of delay and packet loss and node reboots.</p>
<p id="rfc.section.2.1.p.4">Figures 1 - 3 show the reset state machine. In the figures, we use short abbreviations for compactness.  N_L is N_LOCAL, N_R is N_REMOTE, FSN_L is FSN_LOCAL, FSN_R is FSN_REMOTE.  We also abbreviate RESET as RST and RESTACK as RSTACK.  Double line boxes indicate a potentially blocking state that responds to external events (timeouts or packet reception).  Single line boxes indicate transient states the perform some operation.  </p>
<p id="rfc.section.2.1.p.5">Figure 1 shows the initial state of a system as REBOOT.  REBOOT state will ignore any received packets and initialize the state variables.  After rebooting, a node will be in the INIT, INIT state.  From here, it may either receive a RESET message from its peer or send its own RESET message.  In the first case, it proceeds to X2 (the slave state), in the second case it proceeds to X1 (the master state).  </p>
<p id="rfc.section.2.1.p.6">Figure 2 shows the master state, where the system sends out a RESET before receiving a RESET from a peer.  In state SYNC, INIT, the node is waiting for either a RESETACK or a RESET from its peer.  If it does not receive either before its timeout, it will double its timeout and send another RESET</p>
<p id="rfc.section.2.1.p.7">Figure 3 shows the slave state, where the system has received a RESET from its peer before it has sent its own RESET.  This puts the node in the INIT, OK state.  Typically, a node will immediately send its own RESET message, though the RESETACK its sends has the same effect.  This puts the node in the SYNC, OK state.  One of three events can happen: a timeout to send another RESET message, receive a RESETACK or receive another RESET.  Upon receiving a valid RESETACK, the node can move to the OK, OK state. </p>
<div id="rfc.figure.1"/>
<div id="fig-reboot"/>
<pre>
  +-------------------------+
  |                         v
+-------+  recv any       #===============#
| Drop  | &lt;-------------- H    Reboot     H
+-------+                 #===============#
                            |
                            |
                            v
                          +---------------+
                          | N_L=N, N_R=0, |
                          | FSN_R=FSN_L=0 |
                          +---------------+
                            |
                            |
                            v
.........  recv (RST M)   #===============#
: To X2 : &lt;-------------- H  Init, Init   H
:.......:                 #===============#
                            |
                            |
                            v
                          .................
                          :     To X1     :
                          :...............:
</pre>
<p class="figure">Figure 1: Reboot State</p>
<div id="rfc.figure.2"/>
<div id="fig-x1"/>
<pre>
                ......        +-------------------+
                : X1 : ----&gt;  |  Send RST(N_L)    | &lt;--------+
                :....:        +-------------------+          |
                                      |                      |
                                      v                      |
                              +-------------------+   +--------------+
                              |    Start Timer    |   | Inc. Timeout |
                              +-------------------+   +--------------+
                                      |                      ^
                      recv(RST M)     v                      |
 +-------------------+        #===================#  timeout |
 |     N_R = M       | &lt;----- H    Sync, Init     H ---------|
 +-------------------+        #===================#
       |                              | recv(RSTACK N,M)
       v                              v
    .........                 +-------------------+  no    +----------+
    : To X4 :                 |     If N=N_L      | -----&gt; |   Drop   |
    :.......:                 +-------------------+        +----------+
                                      | yes
                                      v
                              +-------------------+
                              |   Cancel Timer    |
                              |   Reset Timeout   |
                              |      N_R = M      |
                              +-------------------+
                                      |
                                      v
                              +-------------------+
                              |       Send        |
                              | RSTACK(N_R, N_L)  | &lt;+
                              +-------------------+  |
                                       |             | yes
                 recv RSTACK(N, M)     v             |
               .........      #===================#  |
               : To X6 : &lt;--- H      OK, OK       H  |
               :.......:      #===================#  |
                                       | recv RST(M) |
                                       v             |
               .........  no  +-------------------+  |
               : To X3 : &lt;--- |     If M=N_R      | -+
               :.......:      +-------------------+
</pre>
<p class="figure">Figure 2: Master State</p>
<div id="rfc.figure.3"/>
<div id="fig-x2"/>
<pre>

    ........       +-------------------+
    :  X2  : ----&gt; |       N_R=M       | &lt;----+
    :......:       +-------------------+      |
                       |                      | recv (RST M)
                       v                      |
                   +-------------------+    #===================#
                   |       Send        | -&gt; H     Init, OK      H
                +&gt; |  RSTAK(N_R, N_L)  |    #===================#
                |  +-------------------+      |
                |                             |
                |  +-------------------+      |
                |  |   Send RST(N_L)   | &lt;----+
                |  |    Start Timer    | &lt;------------------------+
                |  +-------------------+                          |
                |    |                                            |
                |    v                                     recv   |
                |  #====================================# (RST M) |
  +-------------+&gt; H            Sync, OK                H --------+---+
  |             |  #====================================#         |   |
  |             |      | recv (RSTAK N,M)   | timeout             |   |
  |             |      v                    |                     |   |
  |  ........   |    +-----------------+    |      +---------------+  |
  |  :  X6  : --+--&gt; |   If N=N_L      |    +----&gt; | Inc. Timeout  |  |
  |  :......:   |no  +-----------------+           +---------------+  |
  |  +------+   |     | no        | yes                    +----------+
  |  | Drop | &lt;-+-----+           v                        v
  |  +------+   |  +-------------------+           +---------------+
  |             |  |   Cancel Timer    |           | If M=N_REMOTE | yes
  |             |  |   Reset Timeout   |           |               | -+
  |             |  +-------------------+           +---------------+  |
  |             |      |                             | no             |
  |  .........  |      v                             v                |
  |  :   To  :  |    +-----------------+           +---------------+  |
  |  : OK,OK :&lt;-+--- |  If M=M_REMOTE  |           | Cancel Timer  |  |
  |  :.......:  |yes +-----------------+           +---------------+  |
  |             |      | no                          |                |
  |             |      v                             |                |
  |             |  +-------------------+             |                |
  |  ........   +- |      N_R=M,       | &lt;-----------+                |
  |  :  X3  : ---&gt; |   FSN_R=FSN_L=0   |                              |
  |  :......:      +-------------------+                              |
  +--------------------- +    +-------------------+                   |
               ........  +--&lt; |       Send        |                   |
               :  X4  : ----&gt; |  RSTAK(N_R, N_L)  | &lt;-----------------+
               ........       +-------------------+
</pre>
<p class="figure">Figure 3: Slave State</p>
<p/>
<h1 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#init_examples" id="init_examples">Examples</a></h1>
<p id="rfc.section.2.1.1.p.1">The first example, <a href="#example1">Figure 4</a> shows an example message sequence diagram of the initialization process.  The "T" column is Time, The "S" column is for S_LOCAL and S_REMOTE, the N column is for N_LOCAL and N_REMOTE, and the FSN column is for FSN_LOCAL and FSN_REMOTE.  We show both peers, one on the left side of the figure and one on the right side; call them nodes "A" and "B".  We only show an entry in the table when state changes.  </p>

<ul>
  <li>T=0: A initializes and sets its state values as shown, picking the message sequence number 5.  It sends the message {RESET, 5} to B.  It starts a RESET timer.  </li>
  <li>T=2: Node B initializes, picking message sequence number 7.  It sends {RESET, 7} to A.  It starts a RESET timer.  </li>
  <li>T=3: Node A receives {RESET, 7}.  It sets S_REMOTE to OK and records N_REMOTE as 7.  It sets FSN_LOCAL and FSN_REMOTE to 0.  </li>
  <li>T=4: Node A sends {RESET_ACK, 7} to node B.  </li>
  <li>T=5: Node B reeives {RESET_ACK, 7}, so it sets S_LOCAL to OK.  It cancels its RESET timer.  </li>
  <li>T=6: Node A's RESET timer expires and it re-sends {RESET, 5} to B.  </li>
  <li>T=7: Node B receives {RESET, 5}.  It records N_REMOTE as 5 and sets S_REMOTE to OK.  At this point, Node B is in OK/OK state and may begin sending data.  </li>
  <li>T=8: Node B sends {RESET_ACK, 5}.  </li>
  <li>T=9: Node B begins sending data to A.  </li>
  <li>T=9: Node A reveives {RESET_ACK, 5} and sets S_LOCAL to OK.  It is now in OK/OK state and may begin sending data to B.  </li>
  <li>T=10: Node A begins sending data to B.  </li>
</ul>

<p> </p>
<div id="rfc.figure.4"/>
<div id="example1"/>
<pre>
|---|-----|-----|-----|                        |-----|-----|-----|
| T |  S  |  N  | FSN |                        |  S  |  N  | FSN |
|   | L R | L R | L R |                        | L R | L R | L R |
|---|-----|-----|-----|                        |-----|-----|-----|
| 0 | I I | 5 0 | 0 0 | &gt;-{RESET, 5}---------&gt;X|    not ready    |
|   |     |     |     |                        |     |     |     |
| 2 |     |     |     | &lt;---------{RESET, 7}-&lt; | I I | 7 0 | 0 0 |
| 3 |   OK| 5 7 | 0 0 |                        |     |     |     |
| 4 |     |     |     | &gt;-{RESET_ACK, 7, 5}--&gt; |     |     |     |
| 5 |     |     |     |                        |OK   | 7 0 | 0 0 |
| 6 |     |     |     | &gt;-{RESET, 5}---------&gt; |     |     |     |
| 7 |     |     |     |                        |   OK|   5 | 0 0 |
| 8 |     |     |     | &lt;---{RESET_ACK, 5,7}-&lt; |     |     |     |
| 9 |OK   |     |     | &lt;-------------{data}-&lt; |     |     |     |
| 10|     |     |     | &gt;-{data}-------------&gt; |     |     |     |
|---|-----|-----|-----|                        |-----|-----|-----|
</pre>
<p class="figure">Figure 4</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#sender" id="sender">Sender Protocol</a></h1>
<p/>

<ol>
  <li>A sender maintains a separate state machine for each peer.</li>
  <li>When a peering is established, the FragSequenceNumber begins at 0.</li>
  <li>After sending a Fragment, FragSequenceNumber is incremented by one.</li>
  <li>In the first fragment for a packet, set the B bit to '1'.</li>
  <li>In the last fragment for a packet, set the E bit to '1'.</li>
  <li>Both the B and E bits must be set to '1' for a single fragment.</li>
  <li>If both the B and E and I bits are not set, the fragment is in the middle of a series.</li>
  <li>When not sending a fragment (with fragment data), the sender may send an Idle fragment with only the 'I' bit set. This indicates that the sender has no packet to send.  Idle frames may only be sent in between E and B frames.</li>
</ol>

<p> </p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#receiver" id="receiver">Receiver Protocol</a></h1>
<p/>

<ol>
  <li>A receiver maintains one reassembly queue per sender.</li>
  <li>Discard Idle fragments.</li>
  <li>Discard fragments until a 'B' fragment is received.  Store the received sequence number for this sender.</li>
  <li>If an out-of-order fragment is received next, discard the reassembly buffer and go to step (2).</li>
  <li>Continue receiving in-order fragments until the first 'E' fragment.  At this time, the fragmented packet is fully re-assembled and may be passed on to the next layer.</li>
  <li>The receiver cannot assume it will receive the 'E' fragment or a subsequent 'I' frame, so it should use a timeout mechanism appropriate to the link to release preallocated memory resources.</li>
</ol>

<p> </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> Ethernet as a common use case</h1>
<p id="rfc.section.3.p.1">We expect that Ethernet will be the most common L2 technology where the proposed ICN fragmentation will be used, therefore we briefly elaborate on how fragmentation functions with the broadcast and multi-protocol nature of Ethernet.  </p>
<p id="rfc.section.3.p.2">When the fragmentation protocol is used with Ethernet, each participant uses the tuple {source mac, destination mac, ethertype} to identify a send or receive buffer and FragSequenceNumber number space.  </p>
<p id="rfc.section.3.p.3">If the fragmentation protocol is using a group address destination, each group address is considered a "peer" with its own FragSequenceNumber.  For example, the MAC address 0x01005E0017AA on EtherType 0x0801 is the CCNx assigned group address for its 224.0.23.170 IP multicast address.  Each sender would maintain a FragSequenceNumber for that peer.  Each receiver would maintain a separate reassembly buffer for that group address based on the sender and ethertype.  </p>
<p id="rfc.section.3.p.4">If using other Ethernet encapsulations, such as 802.1AE MacSec, one could use a security identifier in place of the {source, destination, ethertype} tuple.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#ccnx_protocol" id="ccnx_protocol">CCNx 1.0 Fragment Protocol Description</a></h1>
<p id="rfc.section.4.p.1">The hop-by-hop fragmentation protocol introduces a new CCNx 1.0 Packet Type called PT_FRAG and uses new fields in the Fixed Header.  The hop-by-hop headers of a CCNx 1.0 fragment may be used for purposes like link quality reporting or a reliable ARQ scheme, which are out-of-scope of this document.  </p>
<p id="rfc.section.4.p.2">We describe a basic hop-by-hop fragmentation header, using bits in the Fixed Header for the fragment encoding.  We also describe an extended version with variable sequence number size that puts the fragmentation header in the body of the CCNx message.  This allows the fragmentation header to be signed or covered by a MIC.  The extended encoding sets the 'X' flag to 1 in the Fixed Header, otherwise it is the basic encoding.</p>
<p id="rfc.section.4.p.3">The "hop-by-hop fixed header" follows the normal conventions: The Version, PacketLength, and HeaderLength fields are as per <a href="#CCNMessages">CCNx Messages in TLV Format</a> <cite title="NONE">[CCNMessages]</cite>.  The PacketType is set to PT_FRAG. However, in the packet-type dependent fields, we reserve 4 bits for flags and 20 bits for a sequence number.</p>
<p id="rfc.section.4.p.4">The "message part" of the CCNx 1.0 fragment carries the fragment data in its own TLV block. The message part may also contain standard CCNx validation algorithm and validation bits in subsequent TLV blocks. In this way, the fragment can be covered by a CRC32C checksum or stronger validation methods.</p>
<p id="rfc.section.4.p.5">The new TLV type T_FRAGMENT wraps the fragment bytes.  It is a top-level message TLV, similar to T_INTEREST or T_OBJECT.</p>
<p id="rfc.section.4.p.6">For sequence number reset, the new TLV types T_FRAG_RESET and T_FRAG_RESET_ACK carry the initialization message sequence number.  They MUST appear in an Idle (I) frame.  A packet MUST NOT have T_FRAGMENT if it has one of these fields.  A single packet may have both a T_FRAG_RESET and a T_FRAG_RESET_ACK.  These fields appear in the CCNx message section.  It is RECOMMENDED to use a 64-bit sequence number, though an implementation MAY use any length appropriate to the media.  </p>
<p id="rfc.section.4.p.7">T_FRAG_RESET and T_FRAG_RESET_ACK may be in either basic header or extended header packets.  In extended header format, the T_FRAG_HEADER element MUST be length 1, which conveys only the flags.</p>
<pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |    PT_FRAG    |         PacketLength          |
+---------------+---------------+---------------+---------------+
|X|B|E|I|          FragSequenceNumber           | HeaderLength  |
+---------------+---------------+---------------+---------------+
/ Optional Hop-by-hop header in TLV format                      /
+---------------+---------------+---------------+---------------+
| Fragment Data TLV                                             /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationAlgorithm TLV                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /
+---------------+---------------+---------------+---------------+
</pre>
<p/>

<ul>
  <li>X: Extended Format (X=0 shown above)</li>
  <li>B: Begin flag.</li>
  <li>E: End flag.</li>
  <li>I: Idle flag.</li>
  <li>FragSequenceNumber: a 20-bit sequence number to identify the fragment (see below).</li>
</ul>

<p> </p>
<p id="rfc.section.4.p.9">The FragSequenceNumber follows <a href="#RFC1982">Serial Number Arithmetic</a> <cite title="NONE">[RFC1982]</cite> for a 20-bit serial number.  This means we have 19 bits of "valid" sequence number space, or 524,288 fragments.  The packets per second for a 10 Gbps link with 1500 bytes Ethernet frames is 833,333 packets per second.  Therefore, the 20-bit sequence number space allows for 629 milliseconds of frames.</p>
<p id="rfc.section.4.p.10">In CCNx 1.0, the maximum encapsulated length is 64 KB -- which requires under 50 PT_FRAG frames of 1500 bytes, depending on the HeaderLength and validation options. So the valid sequence number space (when e.g. used over Ethernet) is approximately 10,500 maximum size (network protocol) packets.  </p>
<p id="rfc.section.4.p.11">If a PT_FRAG packet has optional hop-by-hop headers, the implementation should pass the fragment to the appropriate subsystem to process those headers before discarding the fragment.</p>
<p id="rfc.section.4.p.12">The Extended encoding (X=1) moves the fragment header fields (= flags and sequence number) to the CCNx packet's message part, so they are covered by any ValidationAlgorithm used on the packet.  It also allows for variable length sequence numbers.  In the example shown below, there is a 7-byte (56-bit) sequence number.  </p>
<p id="rfc.section.4.p.13">The Extended encoding also allows different fragmentation protocols to co-exist by changing the opening TLV type from T_FRAG_HEADER to a new type.</p>
<p id="rfc.section.4.p.14">The first 8 bytes of the first fragment are the FixedHeader of the encapsulated Packet, so one may learn the overall length of the Packet from that FixedHeader.</p>
<pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |    PT_FRAG    |         PacketLength          |
+---------------+---------------+---------------+---------------+
|1|0|0|0|                 Reserved              | HeaderLength  |
+---------------+---------------+---------------+---------------+
/ Optional Hop-by-hop header in TLV format                      /
+---------------+---------------+---------------+---------------+
|          T_FRAG_HEADER        |               8               |
+---------------+---------------+---------------+---------------+
|1|B|E|I|0|0|0|0|           FragSequenceNumber                  /
/                                                               /
+---------------+---------------+---------------+---------------+
| Fragment Data TLV                                             /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationAlgorithm TLV                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /
+---------------+---------------+---------------+---------------+
</pre>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#init_packets" id="init_packets">Initialization examples</a></h1>
<p id="rfc.section.4.1.p.1">This section presents examples of initialization packets.</p>
<pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |    PT_FRAG    |         PacketLength          |
+---------------+---------------+---------------+---------------+
|0|0|0|1|                0                      | HeaderLength  |
+---------------+---------------+---------------+---------------+
/ Optional Hop-by-hop header in TLV format                      /
+---------------+---------------+---------------+---------------+
| T_FRAG_RESET (optional)       |               8               |
+---------------+---------------+---------------+---------------+
/ 64-bit N_LOCAL value                                          /
+---------------+---------------+---------------+---------------+
| T_FRAG_RESET_ACK (optional)   |               8               |
+---------------+---------------+---------------+---------------+
/ 64-bit N_LOCAL value                                          /
/ 64-bit N_REMOTE value                                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationAlgorithm TLV                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /
+---------------+---------------+---------------+---------------+
</pre>
<pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |    PT_FRAG    |         PacketLength          |
+---------------+---------------+---------------+---------------+
|1|0|0|0|                 Reserved              | HeaderLength  |
+---------------+---------------+---------------+---------------+
/ Optional Hop-by-hop header in TLV format                      /
+---------------+---------------+---------------+---------------+
|          T_FRAG_HEADER        |               1               |
+---------------+---------------+---------------+---------------+
|1|0|0|1|0|0|0|0|
+---------------+---------------+---------------+---------------+
| T_FRAG_RESET (optional)       |               8               |
+---------------+---------------+---------------+---------------+
/ 64-bit N_LOCAL value                                          /
+---------------+---------------+---------------+---------------+
| T_FRAG_RESET_ACK (optional)   |               8               |
+---------------+---------------+---------------+---------------+
/ 64-bit N_LOCAL value                                          /
/ 64-bit N_REMOTE value                                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationAlgorithm TLV                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /
+---------------+---------------+---------------+---------------+
</pre>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#example" id="example">Example</a></h1>
<p id="rfc.section.4.2.p.1">We present a complete example of the basic fragment encoding for a 2KB Content Object for 1500 byte frames according to the protocol described in this draft (with clear X-flag). The original 2KB packet also has an RSA signature, but this cannot easily be used for integrity checking as the receiver may not have the appropriate key and it is an expensive operation. We therefore chose to use a CRC32C validator on each fragment.  The Content Object has the name ccnx:/abcd.  First, the original 2000 byte packet is shown in entirety.  </p>
<pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|       1       |       2       |              2000             |
+---------------+---------------+---------------+---------------+
|            Reserved           |     Flags     |       20      |
+---------------+---------------+---------------+---------------+
|         T_CACHETIME           |               8               |
+---------------+---------------+---------------+---------------+
|                                                               |
|                    Recommended Cache Time                     |
+---------------+---------------+---------------+---------------+
|       T_CONTENTOBJECT         |              1508             |
+---------------+---------------+---------------+---------------+
|            T_NAME             |               8               |
+---------------+---------------+---------------+---------------+
|         T_NAMESEGMENT         |               4               |
+---------------+---------------+---------------+---------------+
|       a                b              c              d        |
+---------------+---------------+---------------+---------------+
|           T_PAYLOAD           |              1492             |
+---------------+---------------+---------------+---------------+
/                        Payload Contents                       /
+---------------+---------------+---------------+---------------+
|       T_VALIDATION_ALG        |              204              |
+---------------+---------------+---------------+---------------+
|          T_RSA-SHA256         |              200              |
+---------------+---------------+---------------+---------------+
|             T_KEYID           |               32              |
+---------------+---------------+---------------+---------------+
/                            KeyId                              /
/---------------+---------------+-------------------------------+
|          T_PUBLICKEY          |              160              |
+---------------+---------------+---------------+---------------+
/                Public Key (DER encoded SPKI)                  /
+---------------+---------------+---------------+---------------+
|     T_VALIDATION_PAYLOAD      |              256              |
+---------------+---------------+---------------+---------------+
/                          RSA Signature                        /
+---------------+---------------+---------------+---------------+
   </pre>
<p id="rfc.section.4.2.p.2">The 2000 byte packet will be fragmented into two pieces.  In the first fragment, there is 28 bytes of overhead (fixed header 8, T_STD_FRAGMENT 4, validation 16), so the fragment's payload size is 1472 bytes.  In the second packet, the T_FRAGMENT block carries the remaining data 528 bytes, hence the overall packet size is 556 bytes due to the same 28 bytes of overhead.  We used FragSequenceNumber "0" and "1" for the two fragments.</p>
<pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|       1       |    PT_FRAG    |              1500             |
+---------------+---------------+---------------+---------------+
|0|1|0|0|                  0x00000              |       8       |
+---------------+---------------+---------------+---------------+
|          T_FRAGMENT           |             1472              |
+---------------+---------------+---------------+---------------+
|       1       |       2       |              2000             |
+---------------+---------------+---------------+---------------+
|            Reserved           |     Flags     |       20      |
+---------------+---------------+---------------+---------------+
|         T_CACHETIME           |               8               |
+---------------+---------------+---------------+---------------+
|                                                               |
|                    Recommended Cache Time                     |
+---------------+---------------+---------------+---------------+
|       T_CONTENTOBJECT         |              1508             |
+---------------+---------------+---------------+---------------+
|            T_NAME             |               8               |
+---------------+---------------+---------------+---------------+
|         T_NAMESEGMENT         |               4               |
+---------------+---------------+---------------+---------------+
|       a                b              c              d        |
+---------------+---------------+---------------+---------------+
|           T_PAYLOAD           |              1492             |
+---------------+---------------+---------------+---------------+
/             Payload Contents  (1432 out of 1492 bytes)        /
+---------------+---------------+---------------+---------------+
|      T_VALIDATION_ALG         |               4               |
+---------------+---------------+---------------+---------------+
|            T_CRC32            |               0               |
+---------------+---------------+---------------+---------------+
|     T_VALIDATION_PAYLOAD      |               4               |
+---------------+---------------+---------------+---------------+
|                         CRC32C Value                          |
+---------------+---------------+---------------+---------------+
   </pre>
<pre>
                    1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|       1       |    PT_FRAG    |              556              |
+---------------+---------------+---------------+---------------+
|0|0|1|0|                  0x00001              |       8       |
+---------------+---------------+---------------+---------------+
|          T_FRAGMENT           |             528               |
+---------------+---------------+---------------+---------------+
/                Payload Contents  (last 60 bytes)              /
+---------------+---------------+---------------+---------------+
|       T_VALIDATION_ALG        |              204              |
+---------------+---------------+---------------+---------------+
|          T_RSA-SHA256         |              200              |
+---------------+---------------+---------------+---------------+
|             T_KEYID           |               32              |
+---------------+---------------+---------------+---------------+
/                            KeyId                              /
/---------------+---------------+-------------------------------+
|          T_PUBLICKEY          |              160              |
+---------------+---------------+---------------+---------------+
/                Public Key (DER encoded SPKI)                  /
+---------------+---------------+---------------+---------------+
|     T_VALIDATION_PAYLOAD      |              256              |
+---------------+---------------+---------------+---------------+
/                          RSA Signature                        /
+---------------+---------------+---------------+---------------+
|      T_VALIDATION_ALG         |               4               |
+---------------+---------------+---------------+---------------+
|            T_CRC32            |               0               |
+---------------+---------------+---------------+---------------+
|     T_VALIDATION_PAYLOAD      |               4               |
+---------------+---------------+---------------+---------------+
|                         CRC32C Value                          |
+---------------+---------------+---------------+---------------+
   </pre>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#FramePacking" id="FramePacking">CCNx 1.0 Frame Packing</a></h1>
<p id="rfc.section.4.3.p.1">A sender/receiver pair may multiplex non-fragmentation frames on the same link.  For example, in CCNx 1.0, there may be some PacketType PT_FRAG frames and some plain PT_INTEREST or PT_CONTENTOBJECT frames on the same link between the same pairs.  PT_FRAG frames are considered independently of other frames between the pair.</p>
<p id="rfc.section.4.3.p.2">Because each CCNx 1.0 datagram with a Fixed Header has all information needed for framing, two peers may pack multiple CCNx 1.0 datagrams in to one Layer 2 frame.  For example, if there are several small Interests queued back-to-back, they could be encapsulated in a single Ethernet frame, up to the maximum Ethernet payload.</p>
<p id="rfc.section.4.3.p.3">At the extreme, a peer may use fragmentation for all packets and completely pack each Layer 2 frame.  The tail fragment would be cut off at whatever byte length fits the remaining Layer 2 frame.</p>
<pre>
interest1(200B)
content1(3500B)
interest2(200B)
content2(500B)
        </pre>
<pre>
[frag(interest1,200B), frag(content1, 1276B)]
[frag(content1, 1488B)]
[frag(content1, 236B), frag(interest2, 200B), frag(content2, 500B)]
        </pre>
<p id="rfc.section.4.3.p.4">Example: Assume that the outgoing queue for a specific peer has the following four packets to be sent: </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#ndn_protocol" id="ndn_protocol">NDN Fragment Protocol Description</a></h1>
<p id="rfc.section.5.p.1">The Begin-End fragmentation protocol described in this draft extends the NDN link protocol v2 packet format (NDNLPv2). Note that this extension is not an official part of the NDN suite, at this point in time.</p>
<pre>
         NDNpacket      ::= Interest | Data | NDNLP
         NDNLP          ::= NDNLP-TYPE TLV-LENGTH
                              NDNLPhdrFields*
                              NDNLPfragment?
         NDNLPhdrFields ::= BeginEndField | (other NDNLP header fields)
         BeginEndField  ::= BEGIN-END-FIELD-TYPE TLV-LENGTH
                              BYTE BYTE+
         NDNfragment    ::= NDN-FRAGMENT-TYPE TLV-LENGTH
                              BYTE+
</pre>
<p id="rfc.section.5.p.2">NDNLPv2 packets have a start type NDNLP-TYPE which distinguishes them from the classic Interest and Data packets. Inside the NDNLPv2 TLV structure, a sequence of NDNLPv2 header fields precede the payload (fragment data) which is introduced by the type value NND-FRAGMENT-TYPE.  </p>
<p id="rfc.section.5.p.3">The extension for the "begin-end" fragmentation scheme relies on a new header field with type value NDN-BEGIN-END-FIELD-TYPE: The presence of this field marks a NDNLPv2 packet as a "begin-end" fragment. The field's value is 1 to 8 bytes long and consists of 2 flag bits (most-significant bits) plus a sequence number (remaining less-significant bits).</p>
<p id="rfc.section.5.p.4">For a sender/receiver pair and for a given direction, the value of the BeginEndField is of constant size. But depending on the start configuration, different sizes can be chosen for operations, both in time and for the different directions.</p>
<p id="rfc.section.5.p.5">In the smallest possible setup (e.g. sensor network with very small MTUs), the BeginEndField can have a one-byte value (2 flag bits plus 6 sequence number bits). For Ethernet, it it is recommended to use a 3-byte value (2 flag bits plus 22 sequence number bits).</p>
<p id="rfc.section.5.p.6">An idle fragmentation frame is encoded as a NDNLP packet with a Begin-End Field but no NDNfragment element. Both the B- and the E-flags should be set to 1 in this case.</p>
<p id="rfc.section.5.p.7">The frist bytes of the first fragment are the outermost NDN TLV of the encapsulated Packet.  One may learn the overall length from the the outermost TLV length.</p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#NDNexample" id="NDNexample">Example</a></h1>
<p id="rfc.section.5.1.p.1">We present an example of the basic fragment encoding for a payload of size larger than 253 Bytes and less than 64KB.</p>
<pre>
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
| type=NDNLP    | len=N+9                                       |
+---------------+---------------+---------------+---------------+
| type=BeginEnd | len=3         |B|E|        FragSequence...    |
+---------------+---------------+---------------+---------------+
| ..Number      | type=Fragment | len=N                         |
+---------------+---------------+---------------+---------------+
|               | FragmentData (N bytes) ...                    /
+---------------+---------------+---------------+---------------+
/                                                               /
+---------------+---------------+---------------+---------------+
/               |
+---------------+
</pre>
<p/>

<ul>
  <li>B: Begin flag.</li>
  <li>E: End flag.</li>
  <li>FragSequenceNumber: a 22-bit sequence number to identify the fragment.</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#NDNFramePacking" id="NDNFramePacking">NDN Frame Packing</a></h1>
<p id="rfc.section.5.2.p.1">A sender/receiver pair may multiplex non-fragmentation frames on the same link.  For example, in NDN, there may be some NDNLP frames and some plain Interest or Data frames on the same link between the same pairs.  NDNLP frames are considered independently of other frames between the pair.</p>
<p id="rfc.section.5.2.p.2">NDNLP does not allow for frame packing: A frame contains only one out of the three Interest, Data and NDNLP packet types.</p>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#NDNxNumbers" id="NDNxNumbers">Assigned Numbers for NDN Begin-End fragmentation</a></h1>
<pre>
           NDNLP-TYPE            0x64   // official, might change
           BEGIN-END-FIELD-TYPE  0x5c   // inofficial
           NDN-FRAGMENT-TYPE     0x52   // official, might change
</pre>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a></h1>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#IANA" id="IANA">IANA Considerations</a></h1>
<p id="rfc.section.7.p.1">This document adds new values to the CCNx Packet Type Registry and CCNx Message Registry.</p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#iana_packettype" id="iana_packettype">CCNx Packet Type Registry</a></h1>
<pre>
Value    CCNx Packet Type                Definition
----     ------------------------        ----------
4        PT_FRAG                         See Section 4
          </pre>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#iana_message" id="iana_message">CCNx Message Registry</a></h1>
<pre>
Value    CCNx Message Type               Definition
----     ------------------------        ----------
5        T_FRAGMENT                      See Section 4
16       T_FRAG_HEADER                   See Section 4
17       T_FRAG_RESET                    See Section 4
18       T_FRAG_RESET_ACK                See Section 4
          </pre>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#Security" id="Security">Security Considerations</a></h1>
<p id="rfc.section.8.p.1">This protocol has no security mechanisms and is vulnerable to injection attacks by other devices on the same physical link as the fragmentation peers.  One should use a secure Layer 2 protocol, such as 802.1AE (MacSec) to prevent such attacks.</p>
<h1 id="rfc.references"><a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="CCNLite">[CCNLite]</b>
      </td>
      <td class="top"><a title="PARC">Mosko, M.</a>, <a title="PARC">Plass, M.</a> and <a title="University of Basel">C. Tschudin</a>, <a href="http://ccn-lite.net">CCN-Lite fragmentation</a>", Summer 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="CCNMessages">[CCNMessages]</b>
      </td>
      <td class="top"><a title="PARC, Inc.">Mosko, M.</a>, <a title="LinkedIn">Solis, I.</a> and <a title="University of California">C. Wood</a>, "<a href="http://tools.ietf.org/html/draft-irtf-icnrg-ccnxmessages-04">CCNx Messages in TLV Format (Internet draft)</a>", 2016.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="CCNx">[CCNx]</b>
      </td>
      <td class="top"><a>PARC, Inc.</a>, "<a href="http://www.ccnx.org">CCNx Open Source</a>", 2007.</td>
    </tr>
    <tr><td class="reference"><b id="NDN">[NDN]</b></td><td class="top"><a href="http://www.named-data.net/wp-content/uploads/2013/11/packetformat.pdf">NDN specification Documentation, Release 0.1a2</a>", March 2014.</td>, "</tr>
    <tr>
      <td class="reference">
        <b id="NDNLP">[NDNLP]</b>
      </td>
      <td class="top"><a>Shi, J.</a> and <a>B. Zhang</a>, "<a href="http://www.named-data.net/techreports.html">NDNLP: A Link Protocol for NDN</a>", NDN Technical Report NDN-0006, July 2012.</td>
    </tr>
    <tr><td class="reference"><b id="python-sim">[python-sim]</b></td><td class="top"><a href="https://github.com/PARC/ccnx-beginendfragment-sim">ccnx-beginendfragment-sim</a>", December 2016.</td>, "</tr>
    <tr>
      <td class="reference">
        <b id="RFC1982">[RFC1982]</b>
      </td>
      <td class="top"><a>Elz, R.</a> and <a>R. Bush</a>, "<a href="http://tools.ietf.org/html/rfc1982">Serial Number Arithmetic</a>", RFC 1982, DOI 10.17487/RFC1982, August 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1990">[RFC1990]</b>
      </td>
      <td class="top"><a>Sklower, K.</a>, <a>Lloyd, B.</a>, <a>McGregor, G.</a>, <a>Carr, D.</a> and <a>T. Coradetti</a>, "<a href="http://tools.ietf.org/html/rfc1990">The PPP Multilink Protocol (MP)</a>", RFC 1990, DOI 10.17487/RFC1990, August 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3552">[RFC3552]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="http://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5226">[RFC5226]</b>
      </td>
      <td class="top"><a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Marc Mosko</span> 
	  <span class="n hidden">
		<span class="family-name">Mosko</span>
	  </span>
	</span>
	<span class="org vcardline">PARC</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Palo Alto</span>,  
		<span class="region">California</span> 
		<span class="code">94304</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +1 650-812-4405</span>

<span class="vcardline">EMail: <a href="mailto:marc.mosko@parc.com">marc.mosko@parc.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christian Tschudin</span> 
	  <span class="n hidden">
		<span class="family-name">Tschudin</span>
	  </span>
	</span>
	<span class="org vcardline">University of Basel</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Basel</span>,  
		<span class="region"></span>
		<span class="code">4051</span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">Phone: +41 61 267 0557</span>

<span class="vcardline">EMail: <a href="mailto:christian.tschudin@unibas.ch">christian.tschudin@unibas.ch</a></span>

  </address>
</div>

</body>
</html>
