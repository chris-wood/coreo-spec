<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC6920 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6920.xml">
<!ENTITY RFC5280 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5280.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="no" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->

<?rfc private="" ?>

<rfc category="exp" docName="draft-irtf-icnrg-ccnxmessages-latest" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

    <title abbrev="CCNx TLV">CCNx Messages in TLV Format</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Marc Mosko" initials="M.E." surname="Mosko">
      <organization>PARC, Inc.</organization>

      <address>
       <postal>
         <street/>

         <!-- Reorder these if your country does things differently -->

         <city>Palo Alto</city>

         <region>California</region>

         <code>94304</code>

         <country>USA</country>
       </postal>

       <phone>+01 650-812-4405</phone>

       <email>marc.mosko@parc.com</email>

       <!-- uri and facsimile elements may also be added -->
     </address>
    </author>

    <author fullname="Ignacio Solis" initials="I." surname="Solis">
      <organization>LinkedIn</organization>
      <address>
       <postal>
         <street/>
         <!-- Reorder these if your country does things differently -->
         <city>Mountain View</city>
         <region>California</region>
         <code>94043</code>
         <country>USA</country>
       </postal>
       <phone></phone>
       <email>nsolis@linkedin.com</email>
       <!-- uri and facsimile elements may also be added -->
     </address>
    </author>

    <author fullname="Christopher A. Wood" initials="C.A." surname="Wood">
      <organization>University of California Irvine</organization>
      <address>
       <postal>
         <street/>
         <!-- Reorder these if your country does things differently -->
         <city>Irvine</city>
         <region>California</region>
         <code>92697</code>
         <country>USA</country>
       </postal>
       <phone>+01 315-806-5939</phone>
       <email>woodc1@uci.edu</email>
     </address>
    </author>

    <date/>

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
        in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>

    <workgroup>ICNRG</workgroup>

    <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>Content Centric Networking</keyword>

    <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

    <abstract>
      <t>This document specifies version "1" of CCNx message TLV packet format,
          including the TLV types used by each message element and the encoding of each value.
          The semantics of CCNx messages follow the CCNx Semantics specification.</t>
    </abstract>
  </front>

  <middle>
      <section title="Introduction">
       <t>This document specifies a Type-Length-Value (TLV) packet format and the TLV type and value encodings for CCNx messages.
           A full description of the CCNx network protocol, providing an encoding-free description of
           CCNx messages and message elements, may be found in <xref target="CCNSemantics"></xref>. Several
           additional protocols specified in their own documents are in use that extend this specification.</t>

      <t>This document specifies: <list style="symbols">
        <t>The TLV packet format.</t>
        <t>The overall packet format for CCNx messages.</t>
          <t>The TLV types used by CCNx messages.</t>
          <t>The encoding of values for each type.</t>
        <t>Top level types that exist at the outermost containment.</t>
        <t>Interest TLVs that exist within Interest containment.</t>
        <t>Content Object TLVs that exist within Content Object containment.</t>
        </list>
      </t>

       <t>This document is supplemented by this document:
      <list style="symbols">
        <t>Message semantics: see <xref target="CCNSemantics"></xref> for the protocol operation regarding
        Interest and Content Object, including the Interest Return protocol.</t>
        <t>URI notation: see <xref target="CCNxURI"></xref> for the CCNx URI notation.</t>
      </list>
      </t>
       <t>The type values in <xref target="IANA"/> represent the values in common usage today.
         These values may change pending IANA assignments. All type values are
         relative to their parent containers. It is possible for a TLV to redefine a type value defined by
         its parent.  For example, each level of a nested TLV structure might define a "type = 1" with
         a completely different meaning.</t>

       <t>Packets are represented as 32-bit wide words using ASCII art.  Due to
         the nested levels of TLV encoding and the presence of optional fields and variable sizes,
         there is no concise way to represent all possibilities.  We use the convention that ASCII art
         fields enclosed by vertical bars "|" represent exact bit widths.  Fields
         with a forward slash "/" are variable bit widths, which we typically pad
         out to word alignment for picture readability.</t>

      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD
          NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
          described in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>
    </section>

    <section anchor="definitions" title="Definitions">
      <t>
        <list style="symbols">
          <t>Name: A hierarchically structured variable length identifier. It is an ordered list of path
              segments, which may be variable length octet strings. In human-readable form, it is represented
              in URI format as ccnx:/path/part. There is no host or query string. See <xref target="CCNxURI"></xref>
              for complete details.</t>
          <t>Interest: A message requesting a Content Object with a matching Name and other
            optional selectors to choose from multiple objects with the same Name. Any
            Content Object with a Name and optional selectors that matches the Name and optional selectors of the
            Interest is said to satisfy the Interest.</t>
          <t>Content Object: A data object sent in response to an Interest request. It has an (optional) Name and
            a content payload that are bound together via cryptographic means. </t>
        </list>
      </t>
    </section>

    <section anchor="TLV" title="Type-Length-Value (TLV) Packets">
         <t>We use 16-bit Type and 16-bit Length
          fields to encode TLV based packets. This provides 64K different possible types and value field lengths
          of up to 64KiB.  With 64K possible types, there should be sufficient space for basic protocol types,
          while also allowing ample room for experimentation, application use, and growth.</t>

          <t>Specifically, the TLV types in the range 0x1000 - 0x1FFF are reserved for experimental use.
          These type values are reserved in all TLV container contexts. In the event that more space is needed,
          either for types or for length, a new version of the protocol would be needed. See <xref target="vendor"></xref>
          for more information about organization specific TLVs.
            </t>

          <texttable anchor="reserved_types" title="Reserved TLV Types">
              <ttcol align="center">Abbrev</ttcol>
              <ttcol align="center">Name</ttcol>
              <ttcol align="left">Description</ttcol>

             <c>T_ORG</c>
             <c><xref target="vendor">Vendor Specific Information</xref></c>
             <c>Information specific to a vendor implementation (see below).</c>

              <c>n/a</c>
              <c>Experimental</c>
              <c>Experimental use.</c>
          </texttable>


        <figure>
          <artwork align="left"><![CDATA[
                     1                   2
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|              Type             |            Length             |
+---------------+---------------+---------------+---------------+
]]></artwork>
        </figure>

        <t>The Length field contains the length of the Value field in octets.  It does
          not include the length of the Type and Length fields.  They length MAY be zero.
        </t>
        <t>TLV structures are nestable, allowing the Value field of one TLV structure to contain
          additional TLV structures. The enclosing TLV structure is called the container of the enclosed TLV.
        </t>
      <t>Type values are context-dependent.  Within a TLV container, one may re-use previous type values for
      new context-dependent purposes.
      </t>

        <section anchor="packet_format" title="Overall packet format">
          <t>Each packet includes the 8 byte fixed header described below, followed by a set of TLV fields. These fields are
            optional hop-by-hop headers and the Packet Payload.
             </t>

      <figure>
        <artwork align="left"><![CDATA[
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |  PacketType   |         PacketLength          |
+---------------+---------------+---------------+---------------+
|           PacketType specific fields          | HeaderLength  |
+---------------+---------------+---------------+---------------+
/ Optional Hop-by-hop header TLVs                               /
+---------------+---------------+---------------+---------------+
/ PacketPayload TLVs                                            /
+---------------+---------------+---------------+---------------+
]]></artwork>
      </figure>

       <t>The packet payload is a TLV encoding of the CCNx message, followed by optional
       Validation TLVs.</t>
          <figure>
            <artwork align="left"><![CDATA[
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
| CCNx Message TLV                                              /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationAlgorithm TLV                         /
+---------------+---------------+---------------+---------------+
/ Optional CCNx ValidationPayload TLV (ValidationAlg required)  /
+---------------+---------------+---------------+---------------+
]]></artwork>
          </figure>

      <t>This document describes the Version "1" TLV encoding.</t>

      <t>After discarding the fixed and hop-by-hop headers the remaining PacketPayload
        should be a valid protocol message. Therefore, the PacketPayload always begins with
        a 4 byte TLV defining the protocol message (whether it is an Interest, Content Object, or
        other message type) and its total length.
        The embedding of a self-sufficient protocol data unit inside the fixed
        and hop-by-hop headers allows a network stack to discard the headers
        and operate only on the embedded message.</t>

      <t>The range of bytes protected by the Validation includes the CCNx Message and the
        ValidationAlgorithm.</t>

      <t>The ContentObjectHash begins with the CCNx Message and ends at the tail of the packet.</t>
        </section>

         <section anchor="header" title="Fixed Headers">
          <t>CCNx messages begin with an 8 byte fixed header (non-TLV format).
            The HeaderLength field represents the combined length of the Fixed and Hop-by-hop headers.
            The PacketLength field represents the entire Packet length.
          </t>

          <t>A specific PacketType may assign meaning to the "PacketType specific fields".</t>

          <t>The PacketPayload of a CCNx packet is the protocol message itself. The
            Content Object Hash is computed over the PacketPayload only, excluding
            the fixed and hop-by-hop headers as those might change from hop to hop.
            Signed information or Similarity Hashes should not include any
            of the fixed or hop-by-hop headers.
            The PacketPayload should be self-sufficient
            in the event that the fixed and hop-by-hop headers are removed.
          </t>

            <figure>
              <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |  PacketType   |         PacketLength          |
+---------------+---------------+---------------+---------------+
|           PacketType specific fields          | HeaderLength  |
+---------------+---------------+---------------+---------------+
]]></artwork>
            </figure>
            <t>
              <list style="symbols">
                <t>Version: defines the version of the packet.</t>
                <t>HeaderLength: The length of the fixed header (8 bytes) and hop-by-hop headers.
                  The minimum value MUST be "8".</t>
                <t>PacketType: describes forwarder actions to take on the packet.</t>
                <t>PacketLength: Total octets of packet including all headers (fixed header
                  plus hop-by-hop headers) and protocol message.</t>
                <t>PacketType Specific Fields: specific PacketTypes define the use of these bits.</t>
              </list>
            </t>

          <t>The PacketType field indicates how the forwarder should process the packet.
          A Request Packet (Interest) has PacketType PT_INTEREST, a Response (Content Object) has PacketType PT_CONTENT, and an InterestReturn
          Packet has PacketType PT_RETURN.
        </t>

        <t>HeaderLength is the number of octets from the
          start of the packet (Version) to the end of the hop-by-hop headers. PacketLength is
          the number of octets from the start of the packet to the end of the packet.</t>

        <t>The PacketType specific fields are reserved bits whose use depends on the
          PacketType.  They are used for network-level signaling.</t>

        <section title="Interest Fixed Header">
          <t>If the PacketType in the Fixed Header is PT_INTEREST, it indicates that the PacketPayload should be processed
            as an Interest message.
            For this type of packet, the Fixed Header includes a field for a HopLimit as well as Reserved and Flags fields. The Reserved
            field MUST be set to 0 in an Interest - this field will be set to a return code in the case of an Interest Return.
            There are currently no Flags defined, so this field MUST be set to 0.
           </t>

       <figure>
         <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |  PT_INTEREST  |         PacketLength          |
+---------------+---------------+---------------+---------------+
|   HopLimit    |   Reserved    |     Flags     | HeaderLength  |
+---------------+---------------+---------------+---------------+
   ]]></artwork>
      </figure>


      <section anchor="hoplimit" title="Interest HopLimit">
        <t>For an Interest message, the HopLimit is a counter that is decremented with each hop. It limits the
          distance an Interest may travel on the network.  The node originating the
          Interest MAY put in any value - up to the maximum of 255.  Each node that receives
          an Interest with a HopLimit decrements the value upon
          reception.  If the value is 0 after the decrement, the Interest
          MUST NOT be forwarded off the node.</t>

        <t>It is an error to receive an Interest with a 0 hop-limit from a remote node.</t>
        </section>
        </section>
        <section title="Content Object Fixed Header">
          <t>If the PacketType in the Fixed Header is PT_CONTENT, it indicates that the PacketPayload should be processed
            as a Content Object message.
            A Content Object defines a Flags field, however there are currently no flags defined, so
          the Flags field must be set to 0.</t>

          <figure>
            <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |  PT_CONTENT   |         PacketLength          |
+---------------+---------------+---------------+---------------+
|            Reserved           |     Flags     | HeaderLength  |
+---------------+---------------+---------------+---------------+
   ]]></artwork>
          </figure>

        </section>

        <section title="InterestReturn Fixed Header">
          <t>If the PacketType in the Fixed Header is PT_RETURN, it indicates that the PacketPayload should be processed
            as a returned Interest message.
            The only difference between this InterestReturn message and the original Interest is that the PacketType is changed
            to PT_RETURN and a ReturnCode is is put into the Reserved octet.  All other
          fields are unchanged.  The purpose of this encoding is to prevent packet
          length changes so no additional bytes are needed to return an Interest to
          the previous hop.  See <xref target="CCNSemantics"></xref> for a protocol description
          of this packet type.</t>

          <figure>
            <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|    Version    |   PT_RETURN   |         PacketLength          |
+---------------+---------------+---------------+---------------+
|   HopLimit    |  ReturnCode   |     Flags     | HeaderLength  |
+---------------+---------------+---------------+---------------+
   ]]></artwork>
          </figure>


          <section anchor="InterestReturnHopLimit" title="InterestReturn HopLimit">
            <t>This is the original Interest's HopLimit, as received.  It is the value before being
            decremented at the current node (i.e. the received value).</t>
          </section>

          <section anchor="InterestReturnFlags" title="InterestReturn Flags">
            <t>These are the original Flags as set in the Interest.</t>
          </section>

          <section anchor="ReturnCode" title="Return Code">
            <t>The numeric value assigned to the return types is defined below.
            This value is set by the node creating the Interest Return.</t>

            <t>A return code of "0" MUST NOT be used, as it indicates that the returning system
            did not modify the Return Code field.</t>

            <texttable anchor="ReturnCodeTable" title="Return Codes">
              <ttcol align="center">Type</ttcol>
              <ttcol align="left">Return Type</ttcol>

              <c>T_RETURN_NO_ROUTE</c> <c>No Route</c>
              <c>T_RETURN_LIMIT_EXCEEDED</c> <c>Hop Limit Exceeded</c>
              <c>T_RETURN_NO_RESOURCES</c> <c>No Resources</c>
              <c>T_RETURN_PATH_ERROR</c> <c>Path Error</c>
              <c>T_RETURN_PROHIBITED</c> <c>Prohibited</c>
              <c>T_RETURN_CONGESTED</c> <c>Congested</c>
              <c>T_RETURN_MTU_TOO_LARGE</c> <c>MTU too large</c>
              <c>T_RETURN_UNSUPPORTED_HASH_RESTRICTION</c> <c>Unsupported ContentObjectHashRestriction</c>
              <c>T_RETURN_MALFORMED_INTEREST</c> <c>Malformed Interest</c>
            </texttable>
          </section>
        </section>

         </section>

<section anchor="formats" title="Global Formats">
    <t>This section defines global formats that may be nested within other TLVs.</t>

    <section anchor="pad" title="Pad">
        <t>The pad type may be used by protocols that prefer word-aligned
            data.  The size of the word may be defined by the protocol.
            Padding 4-byte words, for example, would use a 1-byte, 2-byte,
            and 3-byte Length.  Padding 8-byte words would use a (0, 1, 2, 3, 5, 6, 7)-byte
            Length.
        </t>

        <t>A pad MAY be inserted after any TLV in the CCNx Message or in the Validation Dependent Data
          In the remainder of this document, we will not show optional pad TLVs.</t>

        <figure>

            <artwork align="left"><![CDATA[
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|             T_PAD             |             Length            |
+---------------+---------------+---------------+---------------+
/                 variable length pad MUST be zeros             /
+---------------+---------------+---------------+---------------+
            ]]></artwork>
        </figure>
    </section>

    <section anchor="vendor" title="Organization Specific TLVs">
        <t>Organization specific TLVs MUST use the T_ORG type. The Length field is the length of the organization
            specific information plus 3. The Value begins with the 3 byte organization number derived from the last
            three digits of the <xref target="EpriseNumbers">IANA Private Enterprise Numbers</xref>, followed by the
            organization specific information.</t>

        <figure>
            <artwork align="left"><![CDATA[
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|             T_ORG             |     Length (3+value length)   |
+---------------+---------------+---------------+---------------+
|   PEN[0]      |    PEN[1]     |     PEN[2]    |               /
+---------------+---------------+---------------+               +
/                  Vendor Specific Value                        /
+---------------+---------------+---------------+---------------+
            ]]></artwork>
        </figure>
    </section>

    <section anchor="hash_format" title="Hash Format">
        <t>Hash values are used in several fields throughout a packet.  This TLV encoding is commonly embedded inside
            those fields to specify the specific hash function used and it's value.  Note that the
            reserved TLV types are also reserved here for user-defined experimental functions.</t>

        <t>The LENGTH field of the hash value MUST be less than or equal to the hash function length.  If the
            LENGTH is less than the full length, it is taken as the left LENGTH bytes of the hash function output.
            Only the specified truncations are allowed.</t>

        <t>This nested format is used because it allows binary comparison of hash values for certain fields
            without a router needing to understand a new hash function.  For example, the KeyIdRestriction is bit-wise
            compared between an Interest's KeyIdRestriction field and a ContentObject's KeyId field.  This format
            means the outer field values do not change with differing hash functions so a router can still identify
            those fields and do a binary comparison of the hash TLV without need to understand the specific
            hash used.  An alternative approach, such as using T_KEYID_SHA512-256, would require each router
            keep an up-to-date parser and supporting user-defined hash functions here would explode the
            parsing state-space.</t>

        <t>A CCN entity MUST support the hash type T_SHA-256. An entity MAY support
            the remaining hash types.</t>

        <texttable anchor="hash_types" title="CCNx Hash Functions">
            <ttcol align="center">Abbrev</ttcol>
            <ttcol align="center">Lengths (octets)</ttcol>

            <c>T_SHA-256</c>
            <c>32</c>

            <c>T_SHA-512</c>
            <c>64, 32</c>

            <c>n/a</c>
            <c>Experimental TLV types</c>
        </texttable>

        <figure title="Example nesting inside type T_FOO">
            <artwork align="left"><![CDATA[
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|             T_FOO             |              36               |
+---------------+---------------+---------------+---------------+
|           T_SHA512            |               32              |
+---------------+---------------+---------------+---------------+
/                        32-byte hash value                     /
+---------------+---------------+---------------+---------------+
            ]]></artwork>
        </figure>
    </section>

    <section anchor="Link" title="Link">
      <t> A Link is the tuple: {Name, [KeyIdRestr], [ContentObjectHashRestr]}.
            It is a general encoding  that is used in both the payload of a Content Object with
            PayloadType = "Link" and
            in the KeyLink field in a KeyLocator.</t>
        <figure>
            <artwork align="left"><![CDATA[
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+-------------------------------+
/ Mandatory CCNx Name                                           /
+---------------+---------------+-------------------------------+
/ Optional KeyIdRestriction                                     /
+---------------------------------------------------------------+
/ Optional ContentObjectHashRestriction                         /
+---------------------------------------------------------------+
            ]]></artwork>
        </figure>
    </section>
</section>

      <section anchor="per-hop" title="Hop-by-hop TLV headers">
        <t>Hop-by-hop TLV headers are unordered and meaning MUST NOT
          be attached to their ordering.
          Three hop-by-hop headers are described in this document:</t>
          <texttable anchor="hbh_types" title="Hop-by-hop Header Types">
            <ttcol align="center">Abbrev</ttcol>
            <ttcol align="center">Name</ttcol>
            <ttcol align="left">Description</ttcol>

            <c>T_INTLIFE</c>
            <c><xref target="Lifetime">Interest Lifetime</xref></c>
            <c>The time an Interest should stay pending at an intermediate node.</c>

            <c>T_CACHETIME</c>
            <c><xref target="RCT">Recommended Cache Time</xref></c>
            <c>The Recommended Cache Time for Content Objects.</c>

            <c>T_MSGHASH</c>
            <c><xref target="MH">Message Hash</xref></c>
            <c>The hash of the CCNx Message to end of packet using <xref target="hash_format"></xref> format.</c>

          </texttable>
        <t>
          Additional hop-by-hop headers are defined in
          higher level specifications such as the fragmentation specification.</t>

          <section anchor="Lifetime" title="Interest Lifetime">
            <t>The Interest Lifetime is the time
              that an
              Interest should stay pending at an intermediate node.
              It is expressed in milliseconds as an unsigned,
              network byte order integer.</t>

            <t>A value of 0 (encoded as 1 byte %x00) indicates the
              Interest does not elicit a Content Object response.  It should still be
              forwarded, but no reply is expected.</t>

            <figure>
              <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|          T_INTLIFE            |             Length            |
+---------------+---------------+---------------+---------------+
/                                                               /
/                      Lifetime (length octets)                 /
/                                                               /
+---------------+---------------+---------------+---------------+
]]></artwork>
            </figure>
          </section>

        <section anchor="RCT" title="Recommended Cache Time">
          <t>The Recommended Cache Time (RCT) is a measure of the useful lifetime of a Content Object as assigned by a content producer or upstream node.
            It serves as a guideline to the Content Store cache in determining how long to keep the Content Object. It is a
            recommendation only and may be ignored by the cache.  This is in contrast to the ExpiryTime (described in <xref target="expiry" />)which takes precedence over
            the RCT and must be obeyed.</t>
           <t>
            Because the Recommended Cache Time is an optional hop-by-hop header and not a part of the signed message, a content producer
            may re-issue a previously signed
            Content Object with an updated RCT without needing to re-sign the message. There is little ill effect from an attacker
            changing the RCT as the RCT serves as a guideline only.</t>
            <t>
            The Recommended Cache Time (a millisecond timestamp) is a network byte ordered unsigned integer of the number of milliseconds
            since the epoch in UTC of when the payload expires. It is a 64-bit field.
            </t>
          <figure>
            <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|         T_CACHETIME           |               8               |
+---------------+---------------+---------------+---------------+
/                                                               /
/                    Recommended Cache Time                     /
/                                                               /
+---------------+---------------+---------------+---------------+
]]></artwork>
          </figure>
        </section>


        <section anchor="MH" title="Message Hash">
            <t>Within a trusted domain, an operator may calculate the message hash at a border device
                and insert that value into the hop-by-hop headers of a message.  An egress device
                should remove the value.  This permits intermediate devices within that trusted domain
                to match against a ContentObjectHashRestriction without calculating it at every hop.</t>

            <t>The message hash is a cryptographic hash from the start of the CCNx Message to the end of
                the packet.  It is used to match against the <xref target="COH">ContentObjectHashRestriction</xref>.
                The Message Hash may be of longer length than an Interest's restriction, in which case the
                device should use the left bytes of the Message Hash to check against the Interest's value.</t>

            <t>The Message Hash may only carry one hash type and there may only be one Message Hash header.</t>

            <t>The Message Hash header is unprotected, so this header is only of practical use within a
                trusted domain, such as an operator's autonomous system.</t>

            <figure title="Message Hash Header">
                <artwork align="left"><![CDATA[
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|          T_MSGHASH            |         (length + 4)          |
+---------------+---------------+---------------+---------------+
|         (hash type)           |            length             |
+---------------+---------------+---------------+---------------+
/                           hash value                          /
+---------------+---------------+---------------+---------------+
                ]]></artwork>
            </figure>
        </section>

      </section>

      <section anchor="top_level" title="Top-Level Types">

        <t>The top-level TLV types listed below exist at the outermost level of a CCNx protocol message.</t>

        <texttable anchor="top_types" title="CCNx Top Level Types">
          <ttcol align="center">Abbrev</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="left">Description</ttcol>

          <c>T_INTEREST</c>
          <c><xref target="CCNMessage">Interest</xref></c>
          <c>An Interest MessageType.</c>

          <c>T_OBJECT</c>
          <c><xref target="CCNMessage">Content Object</xref></c>
          <c>A Content Object MessageType</c>

          <c>T_VALIDATION_ALG</c>
          <c><xref target="ValAlg">Validation Algorithm</xref></c>
          <c>The method of message verification such as
            Message Integrity Check (MIC), a Message Authentication Code (MAC), or a cryptographic signature.
          </c>

          <c>T_VALIDATION_PAYLOAD</c>
          <c><xref target="ValPayload">Validation Payload</xref></c>
          <c>The validation output, such as the CRC32C code or the RSA signature.</c>
        </texttable>
      </section>



        <section anchor="CCNMessage" title="CCNx Message">
          <t>This is the format for the CCNx protocol message itself. The CCNx message is the portion of the packet
            between the hop-by-hop headers and the Validation TLVs. The figure below is an expansion
            of the "CCNx Message TLV" depicted in the beginning of <xref target="TLV" />.
            The CCNx message begins with MessageType and runs through the optional Payload.
            The same general format is used for both Interest and
            Content Object messages which are differentiated by
            the MessageType field. The first enclosed TLV of a CCNx Message is always the
            Name TLV.  This is followed by an optional Message TLVs and an optional Payload TLV.</t>

          <figure>
            <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|         MessageType           |         MessageLength         |
+---------------+---------------+---------------+---------------+
| Name TLV       (Type = T_NAME)                                |
+---------------+---------------+---------------+---------------+
/ Optional Message TLVs   (Various Types)                       /
+---------------+---------------+---------------+---------------+
/ Optional Payload TLV  (Type = T_PAYLOAD)                      /
+---------------+---------------+---------------+---------------+

]]></artwork>
          </figure>


          <texttable anchor="CCNx_types" title="CCNx Message Types">
            <ttcol align="center">Abbrev</ttcol>
            <ttcol align="center">Name</ttcol>
            <ttcol align="left">Description</ttcol>

            <c>T_NAME</c>
            <c><xref target="names">Name</xref></c>
            <c>The CCNx Name requested in an Interest or published in a Content Object.</c>

            <c>T_PAYLOAD</c>
            <c><xref target="content">Payload</xref></c>
            <c>The message payload.</c>
          </texttable>

            <section anchor="names" title="Name">
              <t>A Name is a TLV encoded sequence of
                segments. The table below lists the type values appropriate for these Name
                segments. A Name MUST NOT include PAD TLVs.</t>

              <t>As described in <xref target="CCNSemantics">CCNx Semantics</xref>, using the <xref target="CCNxURI">CCNx URI</xref>
                notation, a T_NAME with 0 length
              corresponds to ccnx:/ (the default route) and is distinct from a name with one zero length segment,
              such as ccnx:/NAME=.  In the TLV encoding, ccnx:/ corresponds to T_NAME with 0 length, while ccnx:/NAME=
              corresponds to T_NAME with 4 length and T_NAMESEGMENT with 0 length.</t>

              <figure>

                <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|            T_NAME             |            Length             |
+---------------+---------------+---------------+---------------+
/ Name segment TLVs                                             /
+---------------+---------------+---------------+---------------+
]]></artwork>
              </figure>

              <texttable anchor="name_types" title="CCNx Name Types">
                <ttcol align="center">Symbolic Name</ttcol>
                <ttcol align="center">Name</ttcol>
                <ttcol align="left">Description</ttcol>

                <c>T_NAMESEGMENT</c>
                <c><xref target="name_segment">Name segment</xref></c>
                <c>A generic name Segment.</c>

                <c>T_IPID</c>
                <c><xref target="name_ipid">Interest Payload ID</xref></c>
                <c>An identifier that represents the Interest Payload field. As an example, the Payload ID might be a hash of the Interest Payload.
                This provides a way to differentiate between Interests based on their payloads without having to parse all the bytes of the payload
                itself; instead using only this Payload ID Name segment.</c>

                <c>T_APP:00 - T_APP:4096</c>
                <c><xref target="name_segment">Application Components</xref></c>
                <c>Application-specific payload in a name segment.  An application may apply
                  its own semantics to the 4096 reserved types.</c>
              </texttable>

              <section anchor="name_segment" title="Name Segments">

              <t> 4096 special application payload name segments are allocated.
                  These have application semantics applied to them.
                  A good convention is to put the application's identity in the
                  name prior to using these name segments.</t>

                <t>For example, a name like "ccnx:/foo/bar/hi"
                  would be encoded as:
                  <figure>

                    <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|            (T_NAME)           |           %x14 (20)           |
+---------------+---------------+---------------+---------------+
|        (T_NAME_SEGMENT)       |           %x03 (3)            |
+---------------+---------------+---------------+---------------+
|       f                o               o      |(T_NAME_SEGMENT)
+---------------+---------------+---------------+---------------+
|               |            %x03 (3)           |       b       |
+---------------+---------------+---------------+---------------+
|      a                r       |           (T_NAME_SEGMENT)    |
+---------------+---------------+---------------+---------------+
|           %x02 (2)            |       h       |       i       |
+---------------+---------------+---------------+---------------+
]]></artwork>
                  </figure>
                </t>

              </section>

              <section anchor="name_ipid" title="Interest Payload ID">
                <t>The InterestPayloadID is a name segment created by the origin of an Interest to
                  represent the Interest Payload.  This allows the proper multiplexing of Interests
                  based on their name if they have different payloads. A common representation is to
                  use a hash of the Interest Payload as the InterestPayloadID.</t>
              <t>
                  As part of the TLV 'value', the InterestPayloadID contains a one identifier of
                  method used to create the InterestPayloadID followed by a variable length octet
                  string.   An implementation is not required to implement any of the methods to
                  receive an Interest; the InterestPayloadID may be treated only as an opaque octet
                  string for purposes of multiplexing Interests with different payloads.  Only a
                  device creating an InterestPayloadID name segment or a device verifying such a
                  segment need to implement the algorithms.</t>
                <t>It uses the <xref target="hash_format"></xref> encoding of hash values.</t>

                  <t>In normal operations, we recommend displaying the InterestPayloadID as an opaque
                    octet string in a CCNx URI, as this is the common denominator for implementation
                    parsing.</t>

                  <t>The InterestPayloadID, even if it is a hash, should not convey any security context.
                  If a system requires confirmation that a specific entity created the InterestPayload,
                  it should use a cryptographic signature on the Interest via the ValidationAlgorithm and
                  ValidationPayload or use its own methods inside the Interest Payload.</t>
              </section>

            </section>


          <!-- =========================================================== -->


        <section anchor="metadata" title="Message TLVs">
         <t>Each message type (Interest or Content Object) is associated with a set of
           optional Message TLVs.  Additional
         specification documents may extend the types associated with each.</t>


          <section anchor="IntMeta" title="Interest Message TLVs">
            <t>There are two Message TLVs currently associated with an Interest message:
              the KeyIdRestriction selector and the ContentObjectHashRestr selector
            are used to narrow the universe of acceptable Content Objects
            that would satisfy the Interest.</t>

            <figure>
              <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|         MessageType           |         MessageLength         |
+---------------+---------------+---------------+---------------+
| Name TLV                                                      |
+---------------+---------------+---------------+---------------+
/ Optional KeyIdRestriction TLV                                 /
+---------------------------------------------------------------+
/ Optional ContentObjectHashRestriction TLV                     /
+---------------------------------------------------------------+
]]></artwork>
            </figure>

            <texttable anchor="InterestMD_types" title="CCNx Interest Message TLV Types">
              <ttcol align="center">Abbrev</ttcol>
              <ttcol align="center">Name</ttcol>
              <ttcol align="left">Description</ttcol>

              <c>T_KEYIDRESTR</c>
              <c><xref target="KeyIdRes">KeyIdRestriction</xref></c>
              <c>A <xref target="hash_format"></xref> representation of the KeyId</c>

              <c>T_OBJHASHRESTR</c>
              <c><xref target="COH">ContentObjectHashRestriction</xref></c>
              <c>A <xref target="hash_format"></xref> representation of the hash of the
                specific Content Object that would satisfy the Interest.</c>
            </texttable>



            <section anchor="KeyIdRes" title="KeyIdRestriction">
              <t>An Interest MAY include a KeyIdRestriction selector.
                This ensures that only Content Objects with matching KeyIds will
                satisfy the Interest. See <xref target="KeyId" /> for the format of a KeyId.</t>


            </section>

            <section anchor="COH" title="ContentObjectHashRestriction">
              <t>An Interest MAY contain a ContentObjectHashRestriction selector. This is
                the hash of the Content Object - the self-certifying name restriction that
                must be verified in the network, if an Interest carried this restriction.
                It is calculated from the beginning of the CCNx Message to the end of the packet.
                The LENGTH MUST be from one of the allowed values for that hash
                (see <xref target="hash_format"></xref>).</t>

              <t>The ContentObjectHashRestriction SHOULD be of type T_SHA-256 and
                  of length 32 bytes.</t>

              <figure>
                <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|        T_OBJHASHRESTR         |            LENGTH+4           |
+---------------+---------------+---------------+---------------+
|          <hash type>          |             LENGTH            |
+---------------+---------------+---------------+---------------+
/                     LENGTH octets of hash                     /
+---------------+---------------+---------------+---------------+
]]></artwork>
              </figure>
            </section>



          </section>

          <section anchor="COmetadata" title="Content Object Message TLVs">
            <t>The following message TLVs are currently defined for Content Objects:
              PayloadType (optional) and ExpiryTime (optional).
              </t>

            <figure>
              <artwork align="left"><![CDATA[
                      1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|         MessageType           |         MessageLength         |
+---------------+---------------+---------------+---------------+
| Name TLV                                                      |
+---------------+---------------+---------------+---------------+
/ Optional PayloadType TLV                                      /
+---------------------------------------------------------------+
/ Optional ExpiryTime TLV                                       /
+---------------------------------------------------------------+

]]></artwork>
            </figure>
            <texttable anchor="objectMD_types" title="CCNx Content Object Message TLV Types">
              <ttcol align="center">Abbrev</ttcol>
              <ttcol align="center">Name</ttcol>
              <ttcol align="left">Description</ttcol>

              <c>T_PAYLDTYPE</c>
              <c><xref target="payload_type">PayloadType</xref></c>
              <c>Indicates the type of Payload contents.</c>

              <c>T_EXPIRY</c>
              <c><xref target="expiry">ExpiryTime</xref></c>
              <c>The time at which the Payload expires, as expressed in the number of milliseconds since the epoch in UTC.
                If missing,
                Content Object may be used as long as desired.</c>


            </texttable>

            <section anchor="payload_type" title="PayloadType">
              <t>The PayloadType is a network byte order integer representing
                the general type of the Payload TLV.
                <list style="symbols">
                  <t>T_PAYLOADTYPE_DATA: Data (possibly encrypted)</t>
                  <t>T_PAYLOADTYPE_KEY: Key</t>
                  <t>T_PAYLOADTYPE_LINK: Link</t>
                </list>
                The Data type indicate that the Payload of the ContentObject
                is opaque application bytes. The Key type indicates that the Payload is a
                DER encoded public key. The Link type indicates that the Payload is one or more
                <xref target="Link">Link</xref>. If this field is missing, a "Data" type is assumed.
              </t>

              <figure>
                <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|            T_PAYLDTYPE        |            Length             |
+---------------+---------------+---------------+---------------+
|  PayloadType  /
+---------------+
]]></artwork>
              </figure>
            </section>

            <section anchor="expiry" title="ExpiryTime">
              <t> The ExpiryTime is the time at which the Payload expires, as expressed by a timestamp containing the number of milliseconds since the epoch in UTC.
                It is a network byte order unsigned integer in a 64-bit field. A cache or end system should not respond with a Content Object past its ExpiryTime.
                Routers forwarding a Content Object do not need to check the ExpiryTime.
                If the ExpiryTime field is missing, the Content Object has no expressed expiration and a cache or end system may use the
                Content Object for as long as desired.
              </t>
              <figure>
                <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|           T_EXPIRY            |               8               |
+---------------+---------------+---------------+---------------+
/                          ExpiryTime                           /
/                                                               /
+---------------+---------------+---------------+---------------+
]]></artwork>
              </figure>
            </section>

        </section>
        </section>
          <section anchor="content" title="Payload">
            <t>The Payload TLV contains the content of the packet.  It MAY be of zero length.
              If a packet does not have any payload, this field MAY be omitted, rather than carrying a zero length.
            </t>

            <figure>
              <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|           T_PAYLOAD           |            Length             |
+---------------+---------------+---------------+---------------+
/                        Payload Contents                       /
+---------------+---------------+---------------+---------------+
]]></artwork>
            </figure>
        </section>




        <section anchor="Validation" title="Validation">

          <t>Both Interests and Content Objects have the option to include information about how to
            validate the CCNx message.
            This information is contained in two TLVs: the
          ValidationAlgorithm TLV and the ValidationPayload TLV.
          The ValidationAlgorithm TLV specifies the mechanism to be used to verify the CCNx message. Examples include verification with a
          Message Integrity Check (MIC), a Message Authentication Code (MAC), or a cryptographic signature.
          The ValidationPayload TLV contains the validation output, such as the CRC32C code or the RSA signature.
          </t>
          <t>An Interest would most likely only use a MIC type of validation - a crc, checksum, or digest.</t>


          <section anchor="ValAlg" title="Validation Algorithm">
            <t>The ValidationAlgorithm is a set of nested TLVs containing all of the information needed to verify the message.
              The outermost container has type = T_VALIDATION_ALG.
              The first nested TLV defines the specific type of validation
            to be performed on the message. The type is identified with the "ValidationType" as shown in
            the figure below and elaborated in the table below.
            Nested within that container are the TLVs for any ValidationType
            dependent data, for example a Key Id, Key Locator etc.</t>

            <t>Complete examples of several types may be found in <xref target="valexamples" /> </t>
          <figure>
            <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|       T_VALIDATION_ALG        |      ValidationAlgLength      |
+---------------+---------------+---------------+---------------+
|        ValidationType         |            Length             |
+---------------+---------------+---------------+---------------+
/ ValidationType dependent data                                 /
+---------------+---------------+---------------+---------------+
]]></artwork>
          </figure>

            <texttable anchor="validator_types" title="CCNx Validation Types">
              <ttcol align="center">Abbrev</ttcol>
              <ttcol align="center">Name</ttcol>
              <ttcol align="left">Description</ttcol>

              <c>T_CRC32C</c>
              <c><xref target="MIC">CRC32C</xref></c>
              <c>Castagnoli CRC32 (iSCSI, ext4, etc.), with normal form polynomial 0x1EDC6F41.</c>

              <c>T_HMAC-SHA256</c>
              <c><xref target="MAC">HMAC-SHA256</xref></c>
              <c>HMAC (RFC 2104) using SHA256 hash.</c>

              <c>T_RSA-SHA256</c>
              <c><xref target="signature_val">RSA-SHA256</xref></c>
              <c>RSA public key signature using SHA256 digest.</c>

              <c>EC-SECP-256K1</c>
              <c><xref target="signature_val">SECP-256K1</xref></c>
              <c>Elliptic Curve signature with SECP-256K1 parameters
                (see <xref target="ECC"></xref>).</c>

              <c>EC-SECP-384R1</c>
              <c><xref target="signature_val">SECP-384R1</xref></c>
              <c>Elliptic Curve signature with SECP-384R1 parameters
                (see <xref target="ECC"></xref>).</c>
            </texttable>

          <section anchor="MIC" title="Message Integrity Checks">
           <t>MICs do not require additional data in order to perform the verification. An example is
             CRC32C that has a "0" length value. </t>
          </section>

            <section anchor="MAC" title="Message Authentication Checks">
            <t>MACs are useful for communication between two trusting parties who have already shared private keys.
              Examples include an RSA signature of a SHA256 digest or others.
              They rely on a KeyId. Some MACs might use more than a KeyId,
              but those would be defined in the future. </t>
            </section>

            <section anchor="signature_val" title="Signature">
              <t>Signature type Validators specify a digest mechanism and a signing algorithm to verify the message.
                Examples include RSA signature og a SHA256 digest, an
                Elliptic Curve signature with SECP-256K1 parameters, etc. These Validators require a KeyId and
              a mechanism for locating the publishers public key (a KeyLocator) -
              optionally a PublicKey or Certificate or KeyLink.</t>
            </section>

            <section anchor="vdd" title="Validation Dependent Data">
              <t>Different Validation Algorithms require access to different pieces of data contained in the ValidationAlgorithm
                TLV. As described above, Key Ids, Key Locators, Public Keys, Certificates, Links and Key Names all play a role
                in different Validation Algorithms. Any number of Validation Dependent Data containers can be present in a Validation
                Algorithm TLV.</t>

              <t>Following is a table of CCNx ValidationType dependent data types:</t>
              <texttable anchor="vddtypes" title="CCNx Validation Dependent Data Types">
                <ttcol align="center">Abbrev</ttcol>
                <ttcol align="center">Name</ttcol>
                <ttcol align="left">Description</ttcol>

                <c>T_KEYID</c>
                <c><xref target="KeyId">SignerKeyId</xref></c>
                <c>An identifier of the shared secret or public key associated with a MAC or Signature.</c>

                <c>T_PUBLICKEY</c>
                <c><xref target="PubKey">Public Key</xref></c>
                <c>DER encoded public key.</c>

                <c>T_CERT</c>
                <c><xref target="Cert">Certificate</xref></c>
                <c>DER encoded X509 certificate.</c>

                <c>T_KEYLINK</c>
                <c><xref target="KeyLink">KeyLink</xref></c>
                <c>A CCNx Link object. </c>

                <c>T_SIGTIME</c>
                <c><xref target="SigTime">SignatureTime</xref></c>
                <c>A millsecond timestamp indicating the time when the signature was created. </c>
              </texttable>
            <section anchor="KeyId" title="KeyId">
              <t>The KeyId is the publisher key identifier. It is similar to a Subject Key Identifier from X509 [RFC 5280, Section 4.2.1.2].
                It should be derived from the key used to sign, such as from the SHA-256 hash of the key.  It
                applies to both public/private key systems and to symmetric key systems.</t>

              <t>The KeyId is represented using the <xref target="hash_format"></xref>.  If a protocol uses a non-hash
                identifier, it should use one of the reserved values.</t>

              <figure>
                <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|            T_KEYID            |            LENGTH+4           |
+---------------+---------------+---------------+---------------+
|          <hash type>          |             LENGTH            |
+---------------+---------------+---------------+---------------+
/                     LENGTH octets of hash                     /
+---------------+---------------+---------------+---------------+

]]></artwork>
              </figure>
            </section>
            <section anchor="PubKey" title="Public Key">
              <t>A Public Key is a DER encoded Subject Public Key Info
                block, as in an X509 certificate.</t>
              <figure>
                <artwork align="left"><![CDATA[
                     1
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+---------------+---------------+---------------+---------------+
|          T_PUBLICKEY          |            Length             |
+---------------+---------------+---------------+---------------+
/                Public Key (DER encoded SPKI)                  /
+---------------+---------------+---------------+---------------+
]]></artwork>
              </figure>
            </section>
            <section anchor="Cert" title="Certificate">
              <figure>
                <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|            T_CERT             |            Length             |
+---------------+---------------+---------------+---------------+
/                 Certificate (DER encoded X509)                /
+---------------+---------------+---------------+---------------+
]]></artwork>
              </figure>
            </section>


            <section anchor="KeyLink" title="KeyLink">
              <t>A KeyLink type KeyLocator is a Link.</t>
              <t>The KeyLink ContentObjectHashRestr, if included, is the digest of
                the Content Object identified by KeyLink, not the digest of the public key.
                Likewise, the KeyIdRestr of the KeyLink is the KeyId of the ContentObject, not
                necessarily of the wrapped key.
              </t>
              <figure>
                <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+-------------------------------+
|          T_KEYKINK            |            Length             |
+---------------+---------------+-------------------------------+
/ Link                                                          /
+---------------------------------------------------------------+
]]></artwork>
              </figure>
            </section>

              <section anchor="SigTime" title="SignatureTime">
                <t>The SignatureTime is a millisecond timestamp indicating the time at which a signature was created.  The signer sets this
                field to the current time when creating a signature. A verifier may use this time to determine whether or not
                the signature was created during the validity period of a key, or if it occurred in a reasonable sequence
                with other associated signatures. The SignatureTime is unrelated to any time associated with the actual CCNx Message,
                which could have been created long before the signature. The default behavior is to always include a SignatureTime when creating
                an authenticated message (e.g. HMAC or RSA).</t>
                <t>SignatureTime is a network byte ordered unsigned integer of the number of milliseconds since the epoch
                in UTC of when the signature was created.  It is a fixed 64-bit field.</t>
                <figure>
                  <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+-------------------------------+
|           T_SIGTIME           |               8               |
+---------------+---------------+-------------------------------+
/                         SignatureTime                         /
+---------------------------------------------------------------+
]]></artwork>
                </figure>
              </section>
            </section>

          <section anchor="valexamples" title="Validation Examples">
            <t>As an example of a MIC type validation, the encoding for CRC32C validation would be:</t>

            <figure>
              <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|      T_VALIDATION_ALG         |               4               |
+---------------+---------------+---------------+---------------+
|            T_CRC32C           |               0               |
+---------------+---------------+---------------+---------------+
]]></artwork>
            </figure>

            <t>As an example of a MAC type validation, the encoding for an HMAC using a SHA256 hash would be:</t>

            <figure>
              <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|       T_VALIDATION_ALG        |               40              |
+---------------+---------------+---------------+---------------+
|        T_HMAC-SHA256          |               36              |
+---------------+---------------+---------------+---------------+
|             T_KEYID           |               32              |
+---------------+---------------+---------------+---------------+
/                            KeyId                              /
/---------------+---------------+-------------------------------+
]]></artwork>
            </figure>

            <t>As an example of a Signature type validation, the encoding for an RSA public key
              signing using a SHA256 digest and Public Key would be:</t>

            <figure>
              <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|       T_VALIDATION_ALG        |      44 + Variable Length     |
+---------------+---------------+---------------+---------------+
|          T_RSA-SHA256         |      40 + Variable Length     |
+---------------+---------------+---------------+---------------+
|             T_KEYID           |               32              |
+---------------+---------------+---------------+---------------+
/                            KeyId                              /
/---------------+---------------+-------------------------------+
|          T_PUBLICKEY          |   Variable Length (~ 160)     |
+---------------+---------------+---------------+---------------+
/                Public Key (DER encoded SPKI)                  /
+---------------+---------------+---------------+---------------+
]]></artwork>
            </figure>


          </section>
          </section>


          <section anchor="ValPayload" title="Validation Payload">
          <figure>
            <artwork align="left"><![CDATA[
                     1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+---------------+---------------+
|     T_VALIDATION_PAYLOAD      |  ValidationPayloadLength      |
+---------------+---------------+---------------+---------------+
/ Type-dependent data                                           /
+---------------+---------------+---------------+---------------+
]]></artwork>
          </figure>

            <t>The ValidationPayload contains the validation output, such as the CRC32C code or the RSA signature.</t>

          </section>

      </section>
    </section>

    <!-- This PI places the pagebreak correctly (before the section title) in the text output. -->
    </section>

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
        <t>This section details each kind of protocol value that can be
            registered. Each type registry can be updated by incrementally
            expanding the type space, i.e., by allocating and reserving new types.
            As per <xref target="RFC5226"/> this section details the creation of
          the "CCNx Registry" and several sub-registries.
        </t>

      <texttable title="Registry Creation">
        <ttcol align="left">Property</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Name</c>
        <c>CCNx Registry</c>
        <c>Abbrev</c>
        <c>CCNx</c>

      </texttable>

    <section anchor="IANA_PacketLevel" title="Packet Type Registry">
        <t> The following packet types should be allocated.  A PacketType MUST be 1 byte.
        New packet types are allocated via "RFC Required" action.</t>

      <texttable title="Registry Creation">
        <ttcol align="left">Property</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Name</c>
        <c>Packet Type Registry</c>

        <c>Parent</c>
        <c>CCNx Registry</c>

        <c>Review process</c>
        <c>RFC Required</c>

        <c>Syntax</c>
        <c>1 octet (decimal)</c>
      </texttable>

        <texttable title="Packet Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>0</c>
          <c>PT_INTEREST</c>
          <c><xref target="header">Fixed Header Types</xref></c>

          <c>1</c>
          <c>PT_CONTENT</c>
          <c><xref target="header">Fixed Header Types</xref></c>

          <c>2</c>
          <c>PT_RETURN</c>
          <c><xref target="header">Fixed Header Types</xref></c>
      </texttable>
    </section>

    <section anchor="IANA_InterestReturnCodes" title="Interest Return Code Registry">
        <t> The following InterestReturn code types should be allocated.</t>

      <texttable title="Registry Creation">
        <ttcol align="left">Property</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Name</c>
        <c>Interest Return Code</c>

        <c>Parent</c>
        <c>CCNx Registry</c>

        <c>Review process</c>
        <c>Expert Review, should include public standard leading to RFC.</c>

        <c>Syntax</c>
        <c>1 octet (decimal)</c>
      </texttable>

        <texttable title="Interest Return Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>1</c>
          <c>T_RETURN_NO_ROUTE</c>
          <c><xref target="ReturnCode">Fixed Header Types</xref></c>

          <c>2</c>
          <c>T_RETURN_LIMIT_EXCEEDED</c>
          <c><xref target="ReturnCode">Fixed Header Types</xref></c>

          <c>3</c>
          <c>T_RETURN_NO_RESOURCES</c>
          <c><xref target="ReturnCode">Fixed Header Types</xref></c>

          <c>4</c>
          <c>T_RETURN_PATH_ERROR</c>
          <c><xref target="ReturnCode">Fixed Header Types</xref></c>

          <c>5</c>
          <c>T_RETURN_PROHIBITED</c>
          <c><xref target="ReturnCode">Fixed Header Types</xref></c>

          <c>6</c>
          <c>T_RETURN_CONGESTED</c>
          <c><xref target="ReturnCode">Fixed Header Types</xref></c>

          <c>7</c>
          <c>T_RETURN_MTU_TOO_LARGE</c>
          <c><xref target="ReturnCode">Fixed Header Types</xref></c>

          <c>8</c>
          <c>T_RETURN_UNSUPPORTED_HASH_RESTRICTION</c>
          <c><xref target="ReturnCode">Fixed Header Types</xref></c>

          <c>9</c>
          <c>T_RETURN_MALFORMED_INTEREST</c>
          <c><xref target="ReturnCode">Fixed Header Types</xref></c>
      </texttable>
    </section>

    <section anchor="IANA_HopByHop" title="Hop-by-Hop Type Registry">
        <t>The following hop-by-hop types should be allocated.</t>

      <texttable title="Registry Creation">
        <ttcol align="left">Property</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Name</c>
        <c>Hop-by-Hop Type Registry</c>

        <c>Parent</c>
        <c>CCNx Registry</c>

        <c>Review process</c>
        <c>RFC Required</c>

        <c>Syntax</c>
        <c>2 octet TLV type (decimal)</c>
      </texttable>

        <texttable title="Hop-by-Hop Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>1</c>
          <c>T_INTLIFE</c>
          <c><xref target="per-hop">Hop-by-hop TLV headers</xref></c>

          <c>2</c>
          <c>T_CACHETIME</c>
          <c><xref target="per-hop">Hop-by-hop TLV headers</xref></c>

          <c>3</c>
          <c>T_MSGHASH</c>
          <c><xref target="per-hop">Hop-by-hop TLV headers</xref></c>

          <c>4 - 7</c>
          <c>Reserved</c>
          <c></c>

          <c>%x0FFE</c>
          <c>T_PAD</c>
          <c><xref target="pad">Pad</xref></c>

          <c>%x0FFF</c>
          <c>T_ORG</c>
          <c><xref target="vendor">Organization-Specific TLVs</xref></c>

          <c>%x1000-%x1FFF</c>
          <c>Reserved</c>
          <c><xref target="TLV">Experimental Use</xref></c>
      </texttable>
    </section>

      <section anchor="IANA_TopLevel" title="Top-Level Type Registry">
        <t> The following top-level types should be allocated.</t>

        <texttable title="Registry Creation">
          <ttcol align="left">Property</ttcol>
          <ttcol align="left">Value</ttcol>

          <c>Name</c>
          <c>Top-Level Type Registry</c>

          <c>Parent</c>
          <c>CCNx Registry</c>

          <c>Review process</c>
          <c>RFC Required</c>

          <c>Syntax</c>
          <c>2 octet TLV type (decimal)</c>
        </texttable>


        <texttable title="Top-Level Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>1</c>
          <c>T_INTEREST</c>
          <c><xref target="top_level">Top-Level Types</xref></c>

          <c>2</c>
          <c>T_OBJECT</c>
          <c><xref target="top_level">Top-Level Types</xref></c>

          <c>3</c>
          <c>T_VALIDATION_ALG</c>
          <c><xref target="top_level">Top-Level Types</xref></c>

          <c>4</c>
          <c>T_VALIDATION_PAYLOAD</c>
          <c><xref target="top_level">Top-Level Types</xref></c>
        </texttable>
      </section>

      <section anchor="IANA_NameSegment" title="Name Segment Type Registry">
        <t>The following name segment types should be allocated.</t>

        <texttable title="Registry Creation">
          <ttcol align="left">Property</ttcol>
          <ttcol align="left">Value</ttcol>

          <c>Name</c>
          <c>Name Segment Type Registry</c>

          <c>Parent</c>
          <c>CCNx Registry</c>

          <c>Review process</c>
          <c>Expert Review with public specification</c>

          <c>Syntax</c>
          <c>2 octet TLV type (decimal)</c>
        </texttable>

        <texttable title="Name Segment Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>1</c>
          <c>T_NAMESEGMENT</c>
          <c><xref target="names">Name</xref></c>

          <c>2</c>
          <c>T_IPID</c>
          <c><xref target="names">Name</xref></c>

          <c>16 - 19</c>
          <c>Reserved</c>
          <c>Used in other drafts</c>

          <c>%x0FFF</c>
          <c>T_ORG</c>
          <c><xref target="vendor">Organization-Specific TLVs</xref></c>

          <c>%x1000 - %x1FFF</c>
          <c>T_APP:00 - T_APP:4096</c>
          <c><xref target="names">Application Components</xref></c>
      </texttable>
    </section>

    <section anchor="IANA_MessageTypes" title="Message Type Registry">
        <t>The following CCNx message segment types should be allocated.</t>

      <texttable title="Registry Creation">
        <ttcol align="left">Property</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Name</c>
        <c>Message Type Registry</c>

        <c>Parent</c>
        <c>CCNx Registry</c>

        <c>Review process</c>
        <c>RFC Required</c>

        <c>Syntax</c>
        <c>2 octet TLV type (decimal)</c>
      </texttable>

        <texttable title="CCNx Message Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>0</c>
          <c>T_NAME</c>
          <c><xref target="CCNMessage">Message Types</xref></c>

          <c>1</c>
          <c>T_PAYLOAD</c>
          <c><xref target="CCNMessage">Message Types</xref></c>

          <c>2</c>
          <c>T_KEYIDRESTR</c>
          <c><xref target="CCNMessage">Message Types</xref></c>

          <c>3</c>
          <c>T_OBJHASHRESTR</c>
          <c><xref target="CCNMessage">Message Types</xref></c>

          <c>5</c>
          <c>T_PAYLDTYPE</c>
          <c><xref target="COmetadata">Content Object Message Types</xref></c>

          <c>6</c>
          <c>T_EXPIRY</c>
          <c><xref target="COmetadata">Content Object Message Types</xref></c>

          <c>7 - 12</c>
          <c>Reserved</c>
          <c>Used in other RFC drafts</c>

          <c>%x0FFE</c>
          <c>T_PAD</c>
          <c><xref target="pad">Pad</xref></c>

          <c>%x0FFF</c>
          <c>T_ORG</c>
          <c><xref target="vendor">Organization-Specific TLVs</xref></c>

          <c>%x1000-%x1FFF</c>
          <c>Reserved</c>
          <c><xref target="TLV">Experimental Use</xref></c>
      </texttable>
    </section>

    <section anchor="IANA_PayloadType" title="Payload Type Registry">
        <t>The following payload types should be allocated.</t>

      <texttable title="Registry Creation">
        <ttcol align="left">Property</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Name</c>
        <c>PayloadType Registry</c>

        <c>Parent</c>
        <c>CCNx Registry</c>

        <c>Review process</c>
        <c>Expert Review with public specification</c>

        <c>Syntax</c>
        <c>Variable length unsigned integer (decimal)</c>
      </texttable>


        <texttable title="Payload Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>0</c>
          <c>T_PAYLOADTYPE_DATA</c>
          <c><xref target="payload_type">Payload Types</xref></c>

          <c>1</c>
          <c>T_PAYLOADTYPE_KEY</c>
          <c><xref target="payload_type">Payload Types</xref></c>

          <c>2</c>
          <c>T_PAYLOADTYPE_LINK</c>
          <c><xref target="payload_type">Payload Types</xref></c>
      </texttable>
    </section>

    <section anchor="IANA_ValidationAlgorithm" title="Validation Algorithm Type Registry">
        <t>The following validation algorithm types should be allocated.</t>

      <texttable title="Registry Creation">
        <ttcol align="left">Property</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Name</c>
        <c>Validation Algorithm Type Registry</c>

        <c>Parent</c>
        <c>CCNx Registry</c>

        <c>Review process</c>
        <c>Expert Review with public specification of the algorithm</c>

        <c>Syntax</c>
        <c>2 octet TLV type (decimal)</c>
      </texttable>

        <texttable title="Validation Algorithm Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>2</c>
          <c>T_CRC32C</c>
          <c><xref target="ValAlg">Validation Algorithm</xref></c>

          <c>4</c>
          <c>T_HMAC-SHA256</c>
          <c><xref target="ValAlg">Validation Algorithm</xref></c>

          <c>5</c>
          <c>T_RSA-SHA256</c>
          <c><xref target="ValAlg">Validation Algorithm</xref></c>

          <c>6</c>
          <c>EC-SECP-256K1</c>
          <c><xref target="ValAlg">Validation Algorithm</xref></c>

          <c>7</c>
          <c>EC-SECP-384R1</c>
          <c><xref target="ValAlg">Validation Algorithm</xref></c>

          <c>%x0FFE</c>
          <c>T_PAD</c>
          <c><xref target="pad">Pad</xref></c>

          <c>%x0FFF</c>
          <c>T_ORG</c>
          <c><xref target="vendor">Organization-Specific TLVs</xref></c>

          <c>%x1000-%x1FFF</c>
          <c>Reserved</c>
          <c><xref target="TLV">Experimental Use</xref></c>
      </texttable>
    </section>

    <section anchor="IANA_ValidationDD" title="Validation Dependent Data Type Registry">
        <t>The following validation dependent data types should be allocated.</t>

      <texttable title="Registry Creation">
        <ttcol align="left">Property</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Name</c>
        <c>Validation Dependent Data Type Registry</c>

        <c>Parent</c>
        <c>CCNx Registry</c>

        <c>Review process</c>
        <c>RFC Required</c>

        <c>Syntax</c>
        <c>2 octet TLV type (decimal)</c>
      </texttable>

        <texttable title="Validation Dependent Data Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>9</c>
          <c>T_KEYID</c>
          <c><xref target="vdd">Validation Dependent Data</xref></c>

          <c>10</c>
          <c>T_PUBLICKEYLOC</c>
          <c><xref target="vdd">Validation Dependent Data</xref></c>

          <c>11</c>
          <c>T_PUBLICKEY</c>
          <c><xref target="vdd">Validation Dependent Data</xref></c>

          <c>12</c>
          <c>T_CERT</c>
          <c><xref target="vdd">Validation Dependent Data</xref></c>

          <c>13</c>
          <c>T_LINK</c>
          <c><xref target="vdd">Validation Dependent Data</xref></c>

          <c>14</c>
          <c>T_KEYLINK</c>
          <c><xref target="vdd">Validation Dependent Data</xref></c>

          <c>15</c>
          <c>T_SIGTIME</c>
          <c><xref target="vdd">Validation Dependent Data</xref></c>

          <c>%x0FFF</c>
          <c>T_ORG</c>
          <c><xref target="vendor">Organization-Specific TLVs</xref></c>

          <c>%x1000-%x1FFF</c>
          <c>Reserved</c>
          <c><xref target="TLV">Experimental Use</xref></c>
      </texttable>
    </section>

    <section anchor="IANA_HashFunctions" title="Hash Function Type Registry">
        <t>The following CCNx hash function types should be allocated.</t>


      <texttable title="Registry Creation">
        <ttcol align="left">Property</ttcol>
        <ttcol align="left">Value</ttcol>

        <c>Name</c>
        <c>Hash Function Type Registry</c>

        <c>Parent</c>
        <c>CCNx Registry</c>

        <c>Review process</c>
        <c>Expert Review with public specification of the hash function</c>

        <c>Syntax</c>
        <c>2 octet TLV type (decimal)</c>
      </texttable>

        <texttable title="CCNx Hash Function Type Namespace">
          <ttcol align="center">Type</ttcol>
          <ttcol align="center">Name</ttcol>
          <ttcol align="center">Reference</ttcol>

          <c>1</c>
          <c>T_SHA-256</c>
          <c><xref target="hash_format">Hash Format</xref></c>

          <c>2</c>
          <c>T_SHA-512</c>
          <c><xref target="hash_format">Hash Format</xref></c>

          <c>%x0FFF</c>
          <c>T_ORG</c>
          <c><xref target="vendor">Organization-Specific TLVs</xref></c>

          <c>%x1000-%x1FFF</c>
          <c>Reserved</c>
          <c><xref target="TLV">Experimental Use</xref></c>
      </texttable>
    </section>

    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        The CCNx message format includes the ability to attach MICs, MACs, and Signatures to
        all packet types.  This does not mean that it is a good idea to use an arbitrary
        ValidationAlgorithm, nor to include computationally expensive algorithms in Interest
        packets, as that could lead to computational DoS attacks.  Application protocols should
        use an explicit protocol to guide their use of packet signatures.
      </t>
      <t>The CCNx message format does not include explicit guidance for encryption.  This is
         covered by other specifications.
      </t>
      <t>Because some implementations may store the entire Name at intermediate hops,
      application designers should use concise names and not store large fields there.
      Deployments may choose to use their own guidelines for name limitations.  There is currently
      no recommended practices for Interest deployments.
      </t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
    1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
    2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
       (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

    Both are cited textually in the same manner: by using xref elements.
    If you use the PI option, xml2rfc will, by default, try to find included files in the same
    directory as the including file. You can also define the XML_LIBRARY environment variable
    with a value containing a set of directories to search.  These can be either in the local
    filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC2119; </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->
      &RFC3552;
      &RFC5226;
      &RFC6920;
      &RFC5280;
      <!-- A reference written by by an organization not a person. -->

      <reference anchor="CCN" target="http://www.CCNx.org">
        <front>
          <title>CCNx Open Source</title>
          <author>
            <organization>PARC, Inc.</organization>
          </author>

          <date year="2007"/>
        </front>
      </reference>

      <reference anchor="CCNSemantics" target="http://tools.ietf.org/html/draft-mosko-icnrg-ccnxsemantics-04">
        <front>
          <title>CCNx Semantics (Internet draft)</title>

          <author initials='M.' surname='Mosko' fullname='Marc Mosko'>
            <organization>PARC, Inc.</organization>
          </author>
          <author initials='I.' surname='Solis' fullname='Ignacio Solis'>
            <organization>LinkedIn</organization>
          </author>
          <author initials='C.' surname='Wood' fullname='Christopher A. Wood'>
            <organization>University of California, Irvine</organization>
          </author>

          <date year="2017"/>
        </front>
      </reference>

      <reference anchor="EpriseNumbers" target="http://www.iana.org/assignments/enterprise-numbers/enterprise-numbers">
        <front>
          <title>IANA Private Enterprise Numbers</title>
          <author>
            <organization>IANA</organization>
          </author>

          <date year="2015"/>
        </front>
      </reference>

      <reference anchor="ECC" target="http://www.secg.org/sec2-v2.pdf">
        <front>
          <title>SEC 2: Recommended Elliptic Curve Domain Parameters</title>
          <author>
            <organization>Certicom Research</organization>
          </author>

          <date year="2010"/>
        </front>
      </reference>

      <reference anchor="CCNxURI" target="http://tools.ietf.org/html/draft-mosko-icnrg-ccnxuri-02">
        <front>
          <title>The CCNx URI Scheme (Internet draft)</title>

          <author initials='M.' surname='Mosko' fullname='Marc Mosko'>
            <organization>PARC, Inc.</organization>
          </author>
          <author initials='C.' surname='Wood' fullname='Christopher A. Wood'>
            <organization>University of California, Irvine.</organization>
          </author>
          <date year="2017"/>
        </front>
      </reference>

    </references>

  </back>
</rfc>
