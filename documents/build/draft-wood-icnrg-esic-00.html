<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Encrypted Sessions In CCNx (ESIC)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions and Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Stateless packet keys"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Inner and Outer Contexts"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Outer Context Names"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Outer Packet"/>
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Consumer Outer Packet"/>
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Producer Outer Packet"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Processing Chain"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Transport State Machine"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Control Channel"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 ESIC Control Packets"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 ESIC Control Messages"/>
<link href="#rfc.section.5" rel="Chapter" title="5 The ESIC API"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations"/>
<link href="#rfc.references" rel="Chapter" title="7 References"/>
<link href="#rfc.references.1" rel="Chapter" title="7.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="7.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Test Vectors"/>
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Sample Encryption TLVs"/>
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Interest Encapsulation Examples"/>
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Content Object Encapsulation Examples"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Mosko, M. and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-wood-icnrg-esic" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-3-06" />
  <meta name="dct.abstract" content="This document describes how to transport CCNx packets inside an encrypted session between peers that share a traffic secret, such as that which is derived from " />
  <meta name="description" content="This document describes how to transport CCNx packets inside an encrypted session between peers that share a traffic secret, such as that which is derived from " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">ICNRG Working Group</td>
  <td class="right">M. Mosko</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">PARC, Inc.</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">C. Wood</td>
</tr>
<tr>
  <td class="left">Expires: September 7, 2015</td>
  <td class="right">University of California Irvine</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">March 06, 2015</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Encrypted Sessions In CCNx (ESIC)<br />
  <span class="filename">draft-wood-icnrg-esic</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes how to transport CCNx packets inside an encrypted session between peers that share a traffic secret, such as that which is derived from <a href="#CCNxKE">[CCNxKE]</a>. The peers create an outer naming context to identify the encryption session in one direction between the consumer and the producer. The consumer sends encrypted Interest messages to the producer, who responds with encrypted Content Objects.  Inside the outer context, the consumer sends Interests with different names, which the producer may respond to or may send InterestReturns for.  There does not need to be a naming relationship between the outer names and the inner names.  The inner content is still protected by normal CCNx authentication mechanisms and possiby encrypted under other schemes.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on September 7, 2015.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Conventions and Terminology</a></li>
</ul><li>2.   <a href="#rfc.section.2">Stateless packet keys</a></li>
<li>3.   <a href="#rfc.section.3">Inner and Outer Contexts</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Outer Context Names</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Outer Packet</a></li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Consumer Outer Packet</a></li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Producer Outer Packet</a></li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Processing Chain</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Transport State Machine</a></li>
</ul><li>4.   <a href="#rfc.section.4">Control Channel</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">ESIC Control Packets</a></li>
<li>4.2.   <a href="#rfc.section.4.2">ESIC Control Messages</a></li>
</ul><li>5.   <a href="#rfc.section.5">The ESIC API</a></li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a></li>
<li>7.   <a href="#rfc.references">References</a></li>
<ul><li>7.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>7.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Test Vectors</a></li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Sample Encryption TLVs</a></li>
<li>A.2.   <a href="#rfc.appendix.A.2">Interest Encapsulation Examples</a></li>
<li>A.3.   <a href="#rfc.appendix.A.3">Content Object Encapsulation Examples</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">CCNx packets <a href="#MESSAGES">[MESSAGES]</a> contain a fixed header, optional hop-by-hop headers, a CCNx Message, and a validation section.  Encrypted Sessions in CCNx (ESIC) describes how to to transport encrypted CCNx packets inside other CCNx packets.  The outer packet (the wrapper) uses a CCNx name that identifies the encrypted session while the inner (encrypted) portion remains hidden and private to an outside observer.</p>
<p id="rfc.section.1.p.2">ESIC defines a new field Encapsulated (T_ENCAP) that may occur in both an Interest (T_INTEREST) and Content Object (T_OBJECT).  The T_ENCAP field contains the encryption of the inner CCNx Packet.</p>
<p id="rfc.section.1.p.3">Because the use of an outer CCNxPacket, the total packet length of the inner CCNxPacket may need to be limited to less than the maximum of 64 KB.  ESIC allows the use of a compressor before the encryptor, so it is likely that a packet that would overflow the 64 KB limit could be compressed by enough to allow for an outer CCNxPacket.  This consideration for the PacketLength is separate from concerns about path MTU.</p>
<p id="rfc.section.1.p.4">It is a requirement of ESIC that one inner packet fit in one outer packet.  This is because ESIC does not define a method to issue extra outer interests to fetch extra outer content objects.  It relies entirely on Interests generated by the consumer application.</p>
<p id="rfc.section.1.p.5">ESIC defines a control channel within the outer context by using special names with the inner packets.  These names allow signaling between the two encryption endpoints for features such as alerts and rekeying requests.</p>
<p id="rfc.section.1.p.6">ESIC defines how to use a traffic secret (TS), such as derived from CCNxKE, to encrypt multiple packets in a consumer-producer session.  Each direction will use separate derived keys.  If one wishes to have a reverse traffic flow (interests from producer fetching content objects from the consumer), then one must share a second TS and use it with the roles reversed, but otherwise it works exactly as in the first case.</p>
<p id="rfc.section.1.p.7">The mechanism by which this symmetric key is obtained is outside the scope of this document; These keys could be pre-shared or derived from an online key-exchange protocol <a href="#CCNxKE">[CCNxKE]</a>.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#conventions-and-terminology" id="conventions-and-terminology">Conventions and Terminology</a></h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.1.1.p.2">The following terms are used:</p>
<p/>

<ul>
  <li>Inner Packet: A fully-formed CCNx packet (fixed header through validation) that is carried encrypted inside a T_ENCAP TLV.</li>
  <li>Outer Packet: A fully-formed CCNx packet that carries the outer context of an encrypted session.</li>
  <li>Outer Name: The name of the outer packet.</li>
  <li>Inner Name: The name of the inner packet (not visible in transport).</li>
  <li>Control channel: the use of Inner Packets to convey control signaling between encryption endpoints using a special Inner Name.</li>
</ul>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#stateless-packet-keys" id="stateless-packet-keys">Stateless packet keys</a></h1>
<p id="rfc.section.2.p.1">ESIC assumes that the consumer and producer share a Traffic Secret (TS), usually derived as per CCNxKE.  Regardless of  how the TS is derived (TODO: it needs to meet some so-far unstated requirements), there are four secrets derived from the TS, as per CCNxKE Section 9.5.  This specifies how to generate the Client Write Key, Server Write Key, Client Write IV, and Server Write IV.</p>
<p id="rfc.section.2.p.2">The AEAD nonce (IV) is derived as specified in <a href="#TLS13">[TLS13]</a>. In particular, the length of the IV for each AEAD operation is set to max(8 bytes, N_MAX), where N_MIN must be at least 8 bytes <a href="#RFC5116">[RFC5116]</a>. With this length, the nonce is initialized by:</p>
<p/>

<ol>
  <li>Padding the 64-bit per-packet AEAD sequence number to the left with zeroes so that its length is equal to the IV length.</li>
  <li>This padded sequence number is then XORed with the consumer or producer IV, depending on the role.</li>
</ol>
<p id="rfc.section.2.p.4">TODO: Should we allow CCNxKE to specify the starting chunk number so it does not always start at 0? It would need to be encoded in the MoveToken.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#inner-and-outer-contexts" id="inner-and-outer-contexts">Inner and Outer Contexts</a></h1>
<p id="rfc.section.3.p.1">The inner context is a CCNx packet with meaning to the consumer and producer.  They may be clear text or they make use additional encryption, such as group keying, broadcast encryption, homomorphic encryption, or something else.  The consumer sends an Interest packet with an Inner Name (plus other optional fields as normal) and expectes to get back a Content Object or InterestReturn packet with corresponding name and fields.</p>
<p id="rfc.section.3.p.2">The outer context names the encryption session and sequences packets.  ESIC does not expect a one-to-one correspondence of outer name and inner name.  If a consumer, for example, sends 3 interests with outer names NO1, NO2, NO3 and inner names NI1, NI2, and NI3, the producer can return those names in any order.  It could put content objects with name NI3 in NO1, NI1 in NO2, and NI2 in NO3.  ESIC does expect normal CCNx processing rules to be followed for the inner packets, therefore we would expect at most one inner packet returned for each inner Interest.  That inner packet could be either a Content Object or Interest Return.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#outer-context-names" id="outer-context-names">Outer Context Names</a></h1>
<p id="rfc.section.3.1.p.1">The outer context name is a routable prefix PREFIX followed by a session ID (SID) followed by a ChunkNumber (Chunk).  The chunk number is a monotonically increasing number.  The outer name is clear text, visible to all observers.</p>
<p id="rfc.section.3.1.p.2">The PREFIX and SID are derived outside of ESIC.  In normal use with CCNxKE, the PREFIX is either the same prefix as used in the key exchagne or it is derived from within CCNxKE from Prefix2 or the MoveToken.  The SID is created by the producer and given to the consumer inside CCNxKE.</p>
<pre>
OuterName := ccnx:/PREFIX/SID=sid/CHUNK=chunk
</pre>
<p id="rfc.section.3.1.p.3">Chunk numbers are limited to 8 bytes and do not wrap around.  When the consumer gets near the end of the sequence number space, it must request a re-keying via the control channel.  Because CCNx in a pull-driven model, the consumer is reponsible for the chunk number and thus responsible for requesting the re-keying.  The producer may also request a re-keying for its own reasons.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#outer-packet" id="outer-packet">Outer Packet</a></h1>
<p id="rfc.section.3.2.p.1">The outer packet will have a Fixed Header, per hop headers, a CCNx Message with the Outer Name, and a Validation section (ValidationAlg and ValidationPayload).  The outer packet is visible to 3rd parties in its entirety.  Only the &#8216;value&#8217; of T_ENCAP TLV field inside the CCNx Message is encrypted.  The T_ENCAP TLV Value is the AEAD &#8216;plaintext&#8217; that will be converted to the &#8216;ciphertext&#8217;.  In the outer packet, only the CCNx Message and the ValidationAlg are covered by the authentication token</p>
<p id="rfc.section.3.2.p.2">The Outer Packet has a Validation section.  The ValidationAlg will have a 0-length ValidationType of T_SESSION, which indidates that the encryption context must be derived from the SID in the name.</p>
<p id="rfc.section.3.2.p.3">The Associated Data (in AEAD) covered by the validation output is from the beignning of the CCNx Message up to but not including the T_ENCAP Value concatendated with the ValidationAlg TLV.  That is, it skips the T_ENCAP TLV Value.</p>
<p id="rfc.section.3.2.p.4">The ValidationPayload contains the AEAD authentication token.</p>
<p id="rfc.section.3.2.p.5">If the Producer cannot satisfy an Inner Packet Interest, it will encapsualte an InterestReturn inside an OuterPacket of PacketType ContentObject.  That is, the InterestReturn is end-to-end signaling about the inner context.</p>
<p id="rfc.section.3.2.p.6">If the Producer has an error with the Outer Context, it may return an InterestReturn for the outer context as normal for Interest processing.</p>
<h1 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#consumer-outer-packet" id="consumer-outer-packet">Consumer Outer Packet</a></h1>
<p id="rfc.section.3.2.1.p.1">The outer packet from the consumer to the producer will always be of PacketType Interest.  They may have any of the normal Interest per-hop headers (e.g. InterestLifetime), which will be visible to 3rd parties and not protected by the encryption or authentication.</p>
<p id="rfc.section.3.2.1.p.2">The Outer Context has a T_INTEREST message type, which contains a T_NAME of the Outer Name.  It may have other additional metadata in clear text.  The T_INTEREST container is protected by the encryption authenticator.  Finally, the T_INTEREST has a T_ENCAP field that contains the encryption of the Inner Packet.  The encryption will use the algorithm negotiated as part of the SID (i.e. AES-GCM).</p>
<h1 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#producer-outer-packet" id="producer-outer-packet">Producer Outer Packet</a></h1>
<p id="rfc.section.3.2.2.p.1">The producer will only send PacketType ContentObject back to the consumer.  The Inner packet may be either an InterestReturn or a ContentObject corresponding to the Inner Packet interest.</p>
<p id="rfc.section.3.2.2.p.2">The outer packet may have per-hop headers (e.g. RecommendedCacheTime) that affect the encrypted packet.  These are independent from the inner Per Hop headers.  The outer MessageType is always T_OBJECT.  It may have normal metadata for a content object, such as ExpiryTime, which affect only the outer packet.  Finally, it has a T_ENCAP that contains the wrapped inner Packet.</p>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#processing-chain" id="processing-chain">Processing Chain</a></h1>
<p id="rfc.section.3.3.p.1">The processing chain from the Source to the Sink is shown below.  The compression/decompression stages are optional and are not strongly tied to the encrypted session.  If used, we assume the compression protocol is session specific to avoid state snooping (e.g. such as in CRIME attack).</p>
<pre>
() indicates output of stage
+------------+   +-------------+   +-----------------+   +---------+
| Source     | - | Compresser  | - | Encypter/Framer | - | Channel |
|(CCNxPacket)|   |(CCNxzPacket)|   | (CCNxPacket)    |   |         |
+------------+   +-------------+   +-----------------+   +---------+

+------------+   +--------------------+   +-------------+   +------+
| Channel    | - | Deframer/Decrypter | - | Decompressor| - | Sink |
|(CCNxPacket)|   | (CCNxzPacket)      |   | (CCNxPacket)|   |      |
+------------+   +--------------------+   +-------------+   +------+
</pre>
<p/>

<ul>
  <li>Source: The source of an Inner Packet.</li>
  <li>Compressor: Optional component to reduce the size before encryption.</li>
  <li>Encrypter/Framer: Creates the ciphertext of the CCNx(z)packet to produce the T_ENCAP, constructs the outer packet, computes the authentication token and generates the ValidationPayload.</li>
  <li>Channel: Carries the wireformat outer packet</li>
  <li>Deframer/Decrypter: Verifies the authenticator, decrypts the T_ENCAP, and passes the Inner Packet to the Decompressor.</li>
  <li>Decompressor: Optional component to expand the inner packet</li>
  <li>Sink: The sink of an Inner Packet.</li>
</ul>
<p id="rfc.section.3.3.p.3">The Encrypter/Framer will generate outer names with sequential outer name chunk numbers.</p>
<p id="rfc.section.3.3.p.4">The Deframer/Decryptor will extract the SID and chunk number from the outer name and use those to create the packet key (see below).  Using the packet key, it will verify the authentication token and if successful decrypt the T_ENCAP.  The output of the T_ENCAP will then be passed to the Sink.</p>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#transport-state-machine" id="transport-state-machine">Transport State Machine</a></h1>
<p id="rfc.section.3.4.p.1">ESIC uses a state machine to manage the ephemeral session such that the Producer knows when the Consumer is finished with the SID.  It also will try to re-request packets that fail authentication before sending its own InterestReturn up the Sink.</p>
<p id="rfc.section.3.4.p.2">The protocol begins with each side knowing the four keys (see Stateless Packet Keys below), the Session ID (SID), and the routable prefix PREFIX.</p>
<p id="rfc.section.3.4.p.3">The receiving process uses a replay buffer to prevent replay attacks.  The buffer tracks the last N out-of-order verified chunks plus the cumulative verified chunk number.  TODO: Sort this out how to avoid replay attacks without requiring reliable in-order delivery.</p>
<p id="rfc.section.3.4.p.4">Protocol of Encrypter/Framer:</p>
<p/>

<ul>
  <li>Initialize: set NextChunkNumber = 0, State = Waiting</li>
  <li>Waiting: Wait for packet from Source (or compressor).  On packet receive, State = Send</li>
  <li>Send: <ul><li>Generate packet key for NextChunkNumber</li><li>Create outer packet with name /PREFIX/SID=sid/CHUNK=NextChunkNumber and the input packet as cleartext in the T_ENCAP.</li><li>Run the AEAD scheme authenticating and encrypting.  Note the prior description of the split Associated Data before and after the plaintext.</li><li>Increment NextChunkNumber</li><li>Send the packet</li><li>State = Waiting</li></ul></li>
</ul>
<p id="rfc.section.3.4.p.6">Protocol of the Deframer/Decrypter:</p>
<p/>

<ul>
  <li>Initialize the replay buffer to empty, State = Waiting.</li>
  <li>Waiting: wait for packet, on input from channel State = Receive</li>
  <li>Receive: <ul><li>Extract the SID and ChunkNumber from name</li><li>If replay, drop</li><li>Authenticate the packet <ul><li>If failed on consumer, send InterestReturn to Source with &#8220;X Error&#8221; (TBD)</li><li>If failed on producer, send failure message to Sink so it can send end-to-end InterestReturn back over channel (if desired) with &#8220;Y Error&#8221; (TBD)</li></ul></li><li>Add packet to replay buffer</li><li>Decrypt packet</li><li>Pass decrypted packet to Sink/Source (or decompressor)</li></ul></li>
</ul>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#control-channel" id="control-channel">Control Channel</a></h1>
<p id="rfc.section.4.p.1">The consumer and producer will need to exchange signaling about the encryption context.  Control and data traffic should be indistinguishable to an external observer.  Therefore, all control signaling is done within the same outer names as data traffic.</p>
<p id="rfc.section.4.p.2">Control signaling is done with a normal Inner Packet that pushes data to the other side.  We use an Interest with an Inner Name of the form shown below, where &#8216;<em>direction</em>&#8217; is &#8216;up&#8217; from the consumer to producer or &#8216;down&#8217; for the producer to consumer.  This allows each side to maintain its own sequence number space in the &#8216;seqnum&#8217;.  This is similar to the use of the sequence number in the DTLS record layer.</p>
<p id="rfc.section.4.p.3">Like DTLS, ESIC control messages are unreliable, though they are uniquely named.</p>
<p id="rfc.section.4.p.4">The payload of the control Interest uses a TLV equivalent of the TLS record format for handshake and alert messages.  Application data is never communicated in these records, as they use an Inner Packet with a different Inner Name.  Inside the payload, a TLV type of Alert (21) or Handshake (22) indicates the purpose of the TLV value.  One may concatenate multiple records in to one payload.</p>
<pre>
ControlName := ccnx:/localhost/esic/_direction_/SID=sid/SEQNUM=seqnum
</pre>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#esic-control-packets" id="esic-control-packets">ESIC Control Packets</a></h1>
<p id="rfc.section.4.1.p.1">A control packet is a CCNx Interest Inner Packet.  The name of the control packet is as above in the /localhost/esic namesapce.  The Payload of the Interest is the actual data.</p>
<p id="rfc.section.4.1.p.2">The ESIC control packet SHOULD be padded out to a length that is indistinguishable from other traffic in the given <em>direction</em>.</p>
<p id="rfc.section.4.1.p.3">The Payload of the Interest contains a set of TLV records using the normal CCNx TLV encoding.  The TLV types and values are defined in the next section.</p>
<p id="rfc.section.4.1.p.4">In the &#8216;up&#8217; direction from the consumer to the producer, a control packet can be inserted into the Interest stream as normal.  The producer may use this extra outer name to return its own control message or send a &#8220;no-op&#8221; back to consume the extra name.</p>
<p id="rfc.section.4.1.p.5">In the &#8216;down&#8217; direction from the producer to the consumer, there is no pre-allocated outer name available.  The producer can only send the consumer a control message if the consumer has outstanding Interests up to the producer.  If there is one or more oustanding interests in the outer name space, the producer normally would send a Content Object or Interest Return corresponding to some inner name.  In this case, the producer would instead inject a control packet Interest in the downstream.  This means the producer is now short one outer Interest in the upstream direction.  Therefore, whenever the Deframer/Decrypter sees a control message in the downstream direction, it MUST insert an upstream &#8220;no-op&#8221; packet, padded out to statistically undetectable length, to give the producer back a missing name slot.</p>
<p id="rfc.section.4.1.p.6">We allow one ESIC control packet in one outer packet.  However, we allow multiple Alert messages to be encoded in the payload, so long as it remains indistinguishable from other packets in the given <em>direction</em>.</p>
<p id="rfc.section.4.1.p.7">Example from a consumer to a producer, where &#8220;NO&#8221; means &#8220;name outer&#8221; and &#8220;NI&#8221; means &#8220;name inner&#8221;.</p>
<pre>
Consumer                                   Producer
   | &gt;------- NO1 : NI1 (Interest) --------&gt;   |
   | &gt;------- NO2 : NI2 (Interest) --------&gt;   |
   | &lt;------- NO1 : NI1 (ContentObject) ---&lt;   |
   | &gt;------- NO3 : NI /local/esic/up/2/1 -&gt;   |
   | &lt;------- NO3 : no-op -----------------&lt;   | (no-op)
   | &lt;------- NO2 : NI2 (ContentObject) ---&lt;   |
</pre>
<p id="rfc.section.4.1.p.8">Here is an example from a producer to a consumer.  The producer uses the second avaialble name NO2 to send a control message to the consumer.  The consumer must then send a no-op packet back up to the producer so it can return the final data packet NI2 inside NO3.</p>
<pre>
Consumer                                   Producer
| &gt;------- NO1 : NI1 (Interest) --------&gt;   |
| &gt;------- NO2 : NI2 (Interest) --------&gt;   |
| &lt;------- NO1 : NI1 (ContentObject) ---&lt;   |
| &lt;------- NO2 : NI /local/esic/dn/2/1 -&lt;   |
| &gt;------- NO3 : -----------------------&gt;   | (no-op)
| &lt;------- NO3 : NI2 (ContentObject) ---&lt;   |
</pre>
<p id="rfc.section.4.1.p.9">TODO: Add examples with loss</p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#esic-control-messages" id="esic-control-messages">ESIC Control Messages</a></h1>
<p id="rfc.section.4.2.p.1">ESIC adopts the TLS 1.3 Alert Protocol for its control messages.  The TLV type of the message inside the control packet payload is taken from the enum AlertDescription.  As per TLS 1.3, fatal Alert messages are an immediate close of the ESIC session.</p>
<p id="rfc.section.4.2.p.2">As per TLS 1.3, each party MUST send a close_nofity message closing the write side of the connection.  In ESIC, this means that when a consumer is done requesting data, it should send a final close_notify.  The producer should then use this outer name to send back its own close_notify.  If for some reason the producer must close before the consumer, it should inject its own close_notify discarding all remaining data and the consumer should send back upstream a close_notify.</p>
<p id="rfc.section.4.2.p.3">The KeyUpdate messages function as per TLS 1.3 Sec 6.3.5.3.  Either side may generate a KeyUpdate message and begin transmitting with the new key.  The other side must update their own key and issue its own KeyUpdate message.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#the-esic-api" id="the-esic-api">The ESIC API</a></h1>
<p id="rfc.section.5.p.1">In this section we describe the ESIC API. Before doing so, we highlight some details that molded the API for both consumers and consumers.</p>
<p/>

<ul>
  <li>Encrypted sessions are bound to names instead of addresses. Consequently, in addition to a set of trusted keys, sessions between a consumer and producer require only a name to be created.</li>
  <li>Sessions are created by an active consumer with a passive peer (producer). Thus, the API must reflect these roles.</li>
  <li>Consumers send and receive whole CCNx messages over a session. Thus, simple read and write functions must be exposed via the API.</li>
  <li>Sessions are not full duplex by default. A producer must specify in its ServerConfiguration construct that it wishes to send interests to the consumer. To maintain transparency, the modality of the resulting session is not reflected in the API.</li>
</ul>
<p id="rfc.section.5.p.3">These observations are distilled in the following ESIC API.</p>
<pre>
# @Consumer: create a secure session with a producer
CCNxSecureSession *ccnxSecureSession_Connect(CCNxPortal *portal, 
    PARCIdentity *identity, CCNxName *servicePrefix);

# @Producer: create a passive listener
CCNxSecureSession *ccnxSecureSession_CreateServer(CCNxPortal *portal, 
    CCNxKeyExchangeConfig *config, CCNxName *servicePrefix);

# @Producer: accept uni- and bi-directional sessions
CCNxSecureSession *ccnxSecureSession_AcceptConnection(CCNxSecureSession *session);
CCNxSecureSession *ccnxSecureSession_AcceptBidirectionalConnection(CCNxSecureSession *session);

# Send a CCNx message
# Override the outer name with the `response` parameter if needed
void ccnxSecureSession_SendMessage(CCNxSecureSession *session, 
    CCNxTlvDictionary *message, const CCNxStackTimeout *timeout, CCNxName *response);

# Receive and decapsulate a CCNx message
# Store the outer name in the `response` parameter.
CCNxMetaMessage *ccnxSecureSession_ReceiveMessage(CCNxSecureSession *session, 
    const CCNxStackTimeout *timeout, CCNxName **response);
</pre>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.6.p.1">It may be possible for an observer to identify which outer packets contain a control (alert) message if the ACK response time shows significant statistical timing different from the normal flow of messages.</p>
<p id="rfc.section.6.p.2">TODO.</p>
<h1 id="rfc.references"><a href="#rfc.references">7.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">7.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr><td class="reference"><b id="CCNxKE">[CCNxKE]</b></td><td class="top"><a href="https://github.com/parc/ccnx-keyexchange-rfc">CCNx Key Exchange Protocol Version 1.0</a>", n.d..</td>, "</tr>
    <tr><td class="reference"><b id="MESSAGES">[MESSAGES]</b></td><td class="top"><a href="https://tools.ietf.org/html/draft-irtf-icnrg-ccnxmessages-02">CCNx Messages in TLV Format</a>", n.d..</td>, "</tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5116">[RFC5116]</b>
      </td>
      <td class="top"><a>McGrew, D.</a>, "<a href="http://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="TLS13">[TLS13]</b>
      </td>
      <td class="top"><a>RTFM, Inc, .</a>, <a href="https://tools.ietf.org/html/draft-ietf-tls-tls13-13">The Transport Layer Security (TLS) Protocol Version 1.3</a>", n.d..</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">7.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC5288">[RFC5288]</b>
      </td>
      <td class="top"><a>Salowey, J.</a>, <a>Choudhury, A.</a> and <a>D. McGrew</a>, "<a href="http://tools.ietf.org/html/rfc5288">AES Galois Counter Mode (GCM) Cipher Suites for TLS</a>", RFC 5288, DOI 10.17487/RFC5288, August 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5389">[RFC5389]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc5389">Session Traversal Utilities for NAT (STUN)</a>", RFC 5389, DOI 10.17487/RFC5389, October 2008.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#test-vectors" id="test-vectors">Test Vectors</a></h1>
<h1 id="rfc.appendix.A.1"><a href="#rfc.appendix.A.1">A.1.</a> <a href="#sample-encryption-tlvs" id="sample-encryption-tlvs">Sample Encryption TLVs</a></h1>
<p id="rfc.section.A.1.p.1">TODO</p>
<h1 id="rfc.appendix.A.2"><a href="#rfc.appendix.A.2">A.2.</a> <a href="#interest-encapsulation-examples" id="interest-encapsulation-examples">Interest Encapsulation Examples</a></h1>
<p id="rfc.section.A.2.p.1">TODO</p>
<h1 id="rfc.appendix.A.3"><a href="#rfc.appendix.A.3">A.3.</a> <a href="#content-object-encapsulation-examples" id="content-object-encapsulation-examples">Content Object Encapsulation Examples</a></h1>
<p id="rfc.section.A.3.p.1">TODO</p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Marc Mosko</span> 
	  <span class="n hidden">
		<span class="family-name">Mosko</span>
	  </span>
	</span>
	<span class="org vcardline">PARC, Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:marc.mosko@parc.com">marc.mosko@parc.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">University of California Irvine</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:woodc1@uci.edu">woodc1@uci.edu</a></span>

  </address>
</div>

</body>
</html>
